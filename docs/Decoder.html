    <HTML>

    <HEAD>
    <TITLE>MIME::Decoder</TITLE>
    </HEAD>

<BODY  LINK="#C00000"    ALINK="#FF2020"  VLINK="#900000" >    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><A HREF="MIME-tools.html">Home</A></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Body.html">MIME::Body</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1 COLOR=#000000>MIME::Decoder</FONT></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Entity.html">MIME::Entity</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Head.html">MIME::Head</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ParserBase.html">MIME::ParserBase</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#400000>MIME::<BR>Decoder</FONT></B></H1>
	    <img src="mime-sm.gif" alt="LOGO">
	    <P><FONT SIZE=+1 COLOR=#400000><I>It's MIME time!</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
	<UL>
		<LI><A HREF="#standard_interface">Standard interface</A>
		<LI><A HREF="#subclass_interface">Subclass interface</A>
		</UL>
	<LI><A HREF="#builtin_decoder_subclasses">BUILT-IN DECODER SUBCLASSES</A>
	<UL>
		<LI><A HREF="#mimedecoderbase64">MIME::Decoder::Base64</A>
		<LI><A HREF="#mimedecoderbinary">MIME::Decoder::Binary</A>
		<LI><A HREF="#mimedecoderquotedprint">MIME::Decoder::QuotedPrint</A>
		<LI><A HREF="#mimedecoderxbit">MIME::Decoder::Xbit</A>
		</UL>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#inputoutput_handles">Input/Output handles</A>
		<LI><A HREF="#writing_a_decoder">Writing a decoder</A>
		</UL>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#version">VERSION</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
<A HREF="Decoder.html">MIME::Decoder</A> - an object for decoding the body
part of a MIME stream


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
<STRONG>Decoding a data stream.</STRONG>

Here's a simple filter program to read quoted-printable data from STDIN
(until EOF) and write the decoded data to STDOUT:


<P>

<PRE>
    use MIME::Decoder;
    
    $decoder = new MIME::Decoder 'quoted-printable' or die &quot;unsupported&quot;;
    $decoder-&gt;decode(\*STDIN, \*STDOUT);
</PRE>

<P>

<STRONG>Encoding a data stream.</STRONG>

Here's a simple filter program to read binary data from STDIN (until EOF)
and write base64-encoded data to STDOUT:


<P>

<PRE>
    use MIME::Decoder;
    
    $decoder = new MIME::Decoder 'base64' or die &quot;unsupported&quot;;
    $decoder-&gt;encode(\*STDIN, \*STDOUT);
</PRE>

<P>

You can <STRONG>write and install your own decoders</STRONG>
 so that <A HREF="Decoder.html">MIME::Decoder</A> will know about them:


<P>

<PRE>
    use MyBase64Decoder;
    
    install MyBase64Decoder 'base64';
</PRE>

<P>

You can also <STRONG>test if an encoding is supported:</STRONG>
 

 


<P>

<PRE>
    if (MIME::Decoder-&gt;supported('x-uuencode')) {
        # we can uuencode!
    }
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
This abstract class, and its private concrete subclasses (see below)
provide an OO front end to the actions of...


<P>

<UL>
<LI><STRONG></STRONG>
Decoding a MIME-encoded stream


<P>

<LI><STRONG></STRONG>
Encoding a raw data stream into a MIME-encoded stream.


<P>

</UL>
The constructor for <A HREF="Decoder.html">MIME::Decoder</A> takes the name
of an encoding (<CODE>base64</CODE>, <CODE>7bit</CODE>, etc.), and returns an instance of a <EM>subclass</EM>

of <A HREF="Decoder.html">MIME::Decoder</A> whose <CODE>decode()</CODE> method will perform the appropriate decoding action, and whose <CODE>encode()</CODE> method will perform the appropriate encoding action.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="public_interface">PUBLIC INTERFACE</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="standard_interface">Standard interface</A></H3>
If all you are doing is <EM>using</EM>
 this class, here's all you'll need...


<P>

<DL>
<DT><STRONG><A NAME="item_new_encoding">new ENCODING

</A></STRONG><DD>
<EM>Class method</EM>
. Create and return a new decoder object which can handle the given
ENCODING.


<P>

<PRE>
    my $decoder = new MIME::Decoder &quot;7bit&quot;;
</PRE>

<P>

Returns the undefined value if no known decoders are appropriate.


<P>

<DT><STRONG><A NAME="item_decode_instreamoutstream">decode INSTREAM,OUTSTREAM

</A></STRONG><DD>
<EM>Instance method.</EM>

Decode the document waiting in the input handle INSTREAM, writing the
decoded information to the output handle OUTSTREAM.


<P>

Read the section in this document on I/O handles for more information about
the arguments. Note that you can still supply old-style unblessed
filehandles for INSTREAM and OUTSTREAM.


<P>

<DT><STRONG><A NAME="item_encode_instreamoutstream">encode INSTREAM,OUTSTREAM

</A></STRONG><DD>
<EM>Instance method.</EM>

Encode the document waiting in the input filehandle INSTREAM, writing the
encoded information to the output stream OUTSTREAM.


<P>

Read the section in this document on I/O handles for more information about
the arguments. Note that you can still supply old-style unblessed
filehandles for INSTREAM and OUTSTREAM.


<P>

<DT><STRONG><A NAME="item_encoding">encoding

</A></STRONG><DD>
<EM>Instance method.</EM>

Return the encoding that this object was created to handle, coerced to all
lowercase (e.g., <CODE>"base64"</CODE>).


<P>

<DT><STRONG><A NAME="item_supported_encoding">supported [ENCODING]

</A></STRONG><DD>
<EM>Class method.</EM>

With one arg (an ENCODING name), returns truth if that encoding is
currently handled, and falsity otherwise. The ENCODING will be
automatically coerced to lowercase:


<P>

<PRE>
    if (MIME::Decoder-&gt;supported('7BIT')) {
        # yes, we can handle it...
    }
    else {
        # drop back six and punt...
    } 
</PRE>

<P>

With no args, returns all the available decoders as a hash reference...
where the key is the encoding name (all lowercase, like '7bit'), and the
associated value is true (it happens to be the name of the class that
handles the decoding, but you probably shouldn't rely on that). Hence:


<P>

<PRE>
    my $supported = MIME::Decoder-&gt;supported;
    if ($supported-&gt;{7bit}) {
        # yes, we can handle it...
    }
    elsif ($supported-&gt;{8bit}) {
        # yes, we can handle it...
    }
</PRE>

<P>

You may safely modify this hash; it will <EM>not</EM>
 change the way the module performs its lookups. Only <CODE>install</CODE> can do that.


<P>

<EM>Thanks to Achim Bohnet for suggesting this method.</EM>





<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="subclass_interface">Subclass interface</A></H3>
If you are writing (or installing) a new decoder subclass, there are some
other methods you'll need to know about:


<P>

<DL>
<DT><STRONG><A NAME="item_decode_it_instreamoutstream">decode_it INSTREAM,OUTSTREAM

</A></STRONG><DD>
<EM>Abstract instance method.</EM>
  
The back-end of the <STRONG>decode</STRONG>
 method. It takes an input handle opened for reading (INSTREAM), and an
output handle opened for writing (OUTSTREAM).


<P>

If you are writing your own decoder subclass, you must override this method
in your class. Your method should read from the input handle via <CODE>getline()</CODE> or <CODE>read()</CODE>, decode this input, and print the decoded data to the output handle via <CODE>print()</CODE>. You may do this however you see fit, so long as the end result is the
same.


<P>

Note that unblessed references and globrefs are automatically turned into
I/O handles for you by <CODE>decode()</CODE>, so you don't need to worry about it.


<P>

Your method must return either <CODE>undef</CODE> (to indicate failure), or <CODE>1</CODE> (to indicate success).


<P>

<DT><STRONG><A NAME="item_encode_it_instreamoutstream">encode_it INSTREAM,OUTSTREAM

</A></STRONG><DD>
<EM>Abstract instance method.</EM>
  
The back-end of the <STRONG>encode</STRONG>
 method. It takes an input handle opened for reading (INSTREAM), and an
output handle opened for writing (OUTSTREAM).


<P>

If you are writing your own decoder subclass, you must override this method
in your class. Your method should read from the input handle via <CODE>getline()</CODE> or <CODE>read()</CODE>, encode this input, and print the encoded data to the output handle via <CODE>print()</CODE>. You may do this however you see fit, so long as the end result is the
same.


<P>

Note that unblessed references and globrefs are automatically turned into
I/O handles for you by <CODE>encode()</CODE>, so you don't need to worry about it.


<P>

Your method must return either <CODE>undef</CODE> (to indicate failure), or <CODE>1</CODE> (to indicate success).


<P>

<DT><STRONG><A NAME="item_init_args">init ARGS...

</A></STRONG><DD>
<EM>Instance method.</EM>

Do any necessary initialization of the new instance, taking whatever
arguments were given to <CODE>new()</CODE>. Should return the self object on success, undef on failure.


<P>

<DT><STRONG><A NAME="item_install_encoding">install ENCODING

</A></STRONG><DD>
<EM>Class method</EM>
. Install this class so that ENCODING is handled by it. You should not
override this method.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="builtin_decoder_subclasses">BUILT-IN DECODER SUBCLASSES</A></H2>
You don't need to <CODE>"use"</CODE> any other Perl modules; the following are included as part of <A
HREF="Decoder.html">MIME::Decoder.</A>


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="mimedecoderbase64">MIME::Decoder::Base64</A></H3>
The built-in decoder for the <CODE>"base64"</CODE> encoding.


<P>

The name was chosen to jibe with the pre-existing <A
HREF="Base64.html">MIME::Base64</A> utility package, which this class
actually uses to translate each line.


<P>

When <STRONG>decoding</STRONG>
, the input is read one line at a time. The input accumulates in an
internal buffer, which is decoded in multiple-of-4-sized chunks (plus a
possible ``leftover'' input chunk, of course).


<P>

When <STRONG>encoding</STRONG>
, the input is read 45 bytes at a time: this ensures that the output lines
are not too long. We chose 45 since it is a multiple of 3 and produces
lines under 76 characters, as RFC-1521 specifies.


<P>

<EM>Thanks to Phil Abercrombie for locating one idiotic bug in this module,
which led me to discover another.</EM>





<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="mimedecoderbinary">MIME::Decoder::Binary</A></H3>
The built-in decoder for a <CODE>"binary"</CODE> encoding (in other words, no encoding).  


<P>

The <CODE>"binary"</CODE> decoder is a special case, since it's ill-advised to read the input
line-by-line: after all, an uncompressed image file might conceivably have
loooooooooong stretches of bytes without a <CODE>"\n"</CODE> among them, and we don't want to risk blowing out our core. So, we
read-and-write fixed-size chunks.


<P>

Both the <STRONG>encoder</STRONG>
 and <STRONG>decoder</STRONG>
 do a simple pass-through of the data from input to output.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="mimedecoderquotedprint">MIME::Decoder::QuotedPrint</A></H3>
The built-in decoder the for <CODE>"quoted-printable"</CODE> encoding.


<P>

The name was chosen to jibe with the pre-existing <A
HREF="QuotedPrint.html">MIME::QuotedPrint</A> utility package, which this
class actually uses to translate each line.


<P>

The <STRONG>decoder</STRONG>
 does a line-by-line translation from input to output.


<P>

The <STRONG>encoder</STRONG>
 does a line-by-line translation, breaking lines so that they fall under the
standard 76-character limit for this encoding.  


<P>

<STRONG>Note:</STRONG>
 just like <A HREF="QuotedPrint.html">MIME::QuotedPrint,</A> we currently
use the native <CODE>"\n"</CODE> for line breaks, and not <CODE>CRLF</CODE>. This may need to change in future versions.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="mimedecoderxbit">MIME::Decoder::Xbit</A></H3>
The built-in decoder for both <CODE>"7bit"</CODE> and <CODE>"8bit"</CODE> encodings, which guarantee short lines (a maximum of 1000 characters per
line) of US-ASCII data compatible with RFC-821.


<P>

The <STRONG>decoder</STRONG>
 does a line-by-line pass-through from input to output, leaving the data
unchanged <EM>except</EM>
 that an end-of-line sequence of CRLF is converted to a newline ``\n''.


<P>

The <STRONG>encoder</STRONG>
 does a line-by-line pass-through from input to output, splitting long lines
if necessary. If created as a 7-bit encoder, any 8-bit characters are
mapped to zero or more 7-bit characters: note that this is a potentially <EM>lossy</EM>
 encoding if you hand it anything but 7-bit input: therefore, don't use it
on binary files (GIFs) and the like; use it only when it ``doesn't matter''
if extra newlines are inserted and 8-bit characters are squished.


<P>

There are several possible ways to use this class to encode arbitrary 8-bit
text as 7-bit text:


<P>

<DL>
<DT><STRONG><A NAME="item_dont_use_this_class">Don't use this class.

</A></STRONG><DD>
Really. Use a more-appropriate encoding, like quoted-printable.


<P>

<DT><STRONG><A NAME="item_approx">APPROX

</A></STRONG><DD>
Approximate the appearance of the Latin-1 character via Internet
conventions; e.g., <CODE>"\c,"</CODE>, <CODE>"\n~"</CODE>, etc. This is the default behavior of this class. It will pull in the <A
HREF="Latin1.html">MIME::Latin1</A> module to do the translation.  <EM>This will be useless to you if your 8-bit characters are not Latin-1 text.</EM>





<P>

<DT><STRONG><A NAME="item_strip">STRIP

</A></STRONG><DD>
Strip out any 8-bit characters. Nice if you're <EM>really</EM>
 sure that any such characters in your input are mistakes to be deleted, but
it'll transform non-English documents into an abbreviated mess. But then,
you should be using <CODE>quoted-printable</CODE> for those...


<P>

<DT><STRONG><A NAME="item_qp">QP

</A></STRONG><DD>
Encode them as though we were doing a quoted-printable encoding; e.g.,
``=A0''. This won't help the mail viewing software, but some humans may get
the gist, and at least the original data might be recoverable...


<P>

</DL>
To affect the default scheme, use the class method:


<P>

<PRE>
    MIME::Decoder::Xbit-&gt;map_8_to_7_by('STRIP');
</PRE>

<P>

To affect just one decoder object:


<P>

<PRE>
    $decoder-&gt;map_8_to_7_by('STRIP');
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="inputoutput_handles">Input/Output handles</A></H3>
As of MIME-tools 2.0, this class has to play nice with the new <A
HREF="Body.html">MIME::Body</A> class... which means that input and output
routines cannot just assume that they are dealing with filehandles.  


<P>

Therefore, all that <A HREF="Decoder.html">MIME::Decoder</A> and its
subclasses require (and, thus, all that they can assume) is that INSTREAMs
and OUTSTREAMs are objects which respond to the messages defined in <STRONG><A HREF="IO.html">MIME::IO</A></STRONG>
 (basically, a subset of those defined by IO::Handle).


<P>

For backwards compatibilty, if you supply a scalar filehandle name (like <CODE>"STDOUT"</CODE>) or an unblessed glob reference (like <CODE>\*STDOUT</CODE>) where an INSTREAM or OUTSTREAM is expected, this package will
automatically wrap it in an object that fits the I/O handle criteria.


<P>

<EM>Thanks to Achim Bohnet for suggesting this more-generic I/O model.</EM>





<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="writing_a_decoder">Writing a decoder</A></H3>
If you're experimenting with your own encodings, you'll probably want to
write a decoder. Here are the basics:


<P>

<OL>
<LI><STRONG><A NAME="item_">



</A></STRONG>
Create a module, like ``MyDecoder::'', for your decoder. Declare it to be a
subclass of <A HREF="Decoder.html">MIME::Decoder.</A>


<P>

<LI><STRONG><A NAME="item_">



</A></STRONG>
Create the following instance methods in your class, as described above:


<P>

<PRE>
    decode_it
    encode_it
    init
</PRE>

<P>

<LI><STRONG><A NAME="item_">



</A></STRONG>
In your application program, activate your decoder for one or more
encodings like this:


<P>

<PRE>
    require MyDecoder;
</PRE>

<P>

<PRE>
    install MyDecoder &quot;7bit&quot;;        # use MyDecoder to decode &quot;7bit&quot;    
    install MyDecoder &quot;x-foo&quot;;       # also, use MyDecoder to decode &quot;x-foo&quot;
</PRE>

<P>

</OL>
To illustrate, here's a custom decoder class for the <CODE>quoted-printable</CODE> 
encoding:


<P>

<PRE>
    package MyQPDecoder;
</PRE>

<P>

<PRE>
    @ISA = qw(MIME::Decoder);    
    use MIME::Decoder;
    use MIME::QuotedPrint;
    
    # decode_it - the private decoding method
    sub decode_it {
        my ($self, $in, $out) = @_;
        
        while (defined($_ = $in-&gt;getline())) {
            my $decoded = decode_qp($_);
	    $out-&gt;print($decoded);
        }
        1;
    }
    
    # encode_it - the private encoding method
    sub encode_it {
        my ($self, $in, $out) = @_;
        
        my ($buf, $nread) = ('', 0); 
        while ($in-&gt;read($buf, 60)) {
            my $encoded = encode_qp($buf);
	    $out-&gt;print($encoded);
        }
        1;
    }
</PRE>

<P>

That's it.


<P>

The task was pretty simple because the <CODE>"quoted-printable"</CODE> 
encoding can easily be converted line-by-line... as can even <CODE>"7bit"</CODE> and <CODE>"8bit"</CODE> (since all these encodings guarantee short lines, with a max of 1000
characters). The good news is: it is very likely that it will be
similarly-easy to write a <A HREF="Decoder.html">MIME::Decoder</A> for any
future standard encodings.


<P>

The <CODE>"binary"</CODE> decoder, however, really required block reads and writes: see <A HREF="#mimedecoderbinary">MIME/Decoder::Binary</A>
 for details.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR</A></H2>
Copyright (c) 1996 by Eryq / <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A>


<P>

All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="version">VERSION</A></H2>
$Revision: 3.202 $ $Date: 1997/01/22 08:32:42 $


<P>

</BODY>
</HTML>
