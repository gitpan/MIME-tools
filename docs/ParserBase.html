    <HTML>

    <HEAD>
    <TITLE>MIME::ParserBase</TITLE>
    </HEAD>

<BODY  LINK="#C00000"    ALINK="#FF2020"  VLINK="#900000" >    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><A HREF="MIME-tools.html">Home</A></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Body.html">MIME::Body</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Decoder.html">MIME::Decoder</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Entity.html">MIME::Entity</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Head.html">MIME::Head</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1 COLOR=#000000>MIME::ParserBase</FONT></B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#400000>MIME::<BR>ParserBase</FONT></B></H1>
	    <img src="mime-sm.gif" alt="LOGO">
	    <P><FONT SIZE=+1 COLOR=#400000><I>It's MIME time!</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
	<UL>
		<LI><A HREF="#construction_and_setting_options">Construction, and setting options</A>
		<LI><A HREF="#parsing_messages">Parsing messages</A>
		</UL>
	<LI><A HREF="#writing_subclasses">WRITING SUBCLASSES</A>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#under_the_hood">Under the hood</A>
		<LI><A HREF="#questionable_practices">Questionable practices</A>
		</UL>
	<LI><A HREF="#warnings">WARNINGS</A>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#version">VERSION</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
<A HREF="ParserBase.html">MIME::ParserBase</A> - abstract class for parsing
MIME mail


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
This is an <EM>abstract</EM>
 class; however, here's how one of its 
<EM>concrete subclasses</EM>
 is used:


<P>

<PRE>
    use MIME::Parser;
    
    # Create a new parser object:
    my $parser = new MIME::Parser;
    
    # Parse an input stream:
    $entity = $parser-&gt;read(\*STDIN) or die &quot;couldn't parse MIME stream&quot;;
    
    # Congratulations: you now have a (possibly multipart) MIME entity!
    $entity-&gt;dump_skeleton;          # for debugging 
</PRE>

<P>

There are also some convenience methods:


<P>

<PRE>
    # Parse already-split input (as &quot;deliver&quot; would give it to you):
    $entity = $parser-&gt;parse_two(&quot;msg.head&quot;, &quot;msg.body&quot;)
          || die &quot;couldn't parse MIME files&quot;;
</PRE>

<P>

In case a parse fails, it's nice to know who sent it to us. So...


<P>

<PRE>
    # Parse an input stream:
    $entity = $parser-&gt;read(\*STDIN);
    if (!$entity) {           # oops!
	my $decapitated = $parser-&gt;last_head;    # last top-level head
    }
</PRE>

<P>

You can also alter the behavior of the parser:    


<P>

<PRE>
    # Parse contained &quot;message/rfc822&quot; objects as nested MIME streams:
    $parser-&gt;parse_nested_messages(1);
     
    # Automatically attempt to RFC-1522-decode the MIME headers:
    $parser-&gt;decode_headers(1);
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
Where it all begins.  


<P>

This is the class that contains all the knowledge for <EM>parsing</EM>
 MIME streams. It's an abstract class, containing no methods governing the <EM>output</EM>
 of the parsed entities: such methods belong in the concrete subclasses.


<P>

You can inherit from this class to create your own subclasses that parse
MIME streams into <A HREF="Entity.html">MIME::Entity</A> objects. One such
subclass, 
<STRONG><A HREF="Parser.html">MIME::Parser</A></STRONG>
, is already provided in this kit.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="public_interface">PUBLIC INTERFACE</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="construction_and_setting_options">Construction, and setting options</A></H3>
<DL>
<DT><STRONG><A NAME="item_new_args">new ARGS...

</A></STRONG><DD>
<EM>Class method.</EM>

Create a new parser object. Passes any subsequent arguments onto the <CODE>init()</CODE> method.


<P>

Once you create a parser object, you can then set up various parameters
before doing the actual parsing. Here's an example using one of our
concrete subclasses:


<P>

<PRE>
    my $parser = new MIME::Parser;
    $parser-&gt;output_dir(&quot;/tmp&quot;);
    $parser-&gt;output_prefix(&quot;msg1&quot;);
    my $entity = $parser-&gt;read(\*STDIN);
</PRE>

<P>

<DT><STRONG><A NAME="item_decode_headers_onoff">decode_headers ONOFF

</A></STRONG><DD>
<EM>Instance method.</EM>

If set true, then the parser will attempt to decode the MIME headers as per
RFC-1522 the moment it sees them. This will probably be of most use to
those of you who expect some international mail, especially mail from
individuals with 8-bit characters in their names.


<P>

If set false, no attempt at decoding will be done.


<P>

With no argument, just returns the current setting.


<P>

<STRONG>Warning:</STRONG>
 some folks already have code which assumes that no decoding is done, and
since this is pretty new and radical stuff, I have initially made ``off''
the default setting for backwards compatibility in 2.05. However, I will
possibly change this in future releases, so <EM>please:</EM>

if you want a particular setting, declare it when you create your parser
object.


<P>

<DT><STRONG><A NAME="item_interface_rolevalue">interface ROLE,[VALUE]

</A></STRONG><DD>
<EM>Instance method.</EM>

During parsing, the parser normally creates instances of certain classes,
like <A HREF="Entity.html">MIME::Entity.</A> However, you may want to
create a parser subclass that uses your own experimental head, entity, etc.
classes (for example, your ``head'' class may provide some additional
MIME-field-oriented methods).


<P>

If so, then this is the method that your subclass should invoke during
init. Use it like this:


<P>

<PRE>
    package MyParser;
    @ISA = qw(MIME::Parser);
    ...
    sub init {
	my $self = shift;
	$self-&gt;SUPER::init(@_);        # do my parent's init
        $self-&gt;interface(ENTITY_CLASS =&gt; 'MIME::MyEntity');
	$self-&gt;interface(HEAD_CLASS   =&gt; 'MIME::MyHead');
	$self;                         # return
    }
</PRE>

<P>

With no VALUE, returns the VALUE currently associated with that ROLE.


<P>

<DT><STRONG><A NAME="item_last_head">last_head

</A></STRONG><DD>
<EM>Instance method.</EM>

Return the top-level MIME header of the last stream we attempted to parse.
This is useful for replying to people who sent us bad MIME messages.


<P>

<PRE>
    # Parse an input stream:
    $entity = $parser-&gt;read(\*STDIN);
    if (!$entity) {           # oops!
	my $decapitated = $parser-&gt;last_head;    # last top-level head
    }
</PRE>

<P>

<DT><STRONG><A NAME="item_parse_nested_messages_option">parse_nested_messages OPTION

</A></STRONG><DD>
<EM>Instance method.</EM>

Some MIME messages will contain a part of type <CODE>message/rfc822</CODE>: literally, the text of an embedded mail message. The normal behavior is
to save such a message just as if it were a <CODE>text/plain</CODE> 
document. However, you can change this: before parsing, invoke this method
with the OPTION you want:


<P>

<STRONG>If OPTION is false,</STRONG>
 the normal behavior will be used.


<P>

<STRONG>If OPTION is true,</STRONG>
 the body of the <CODE>message/rfc822</CODE> part is decoded (after all, it might be encoded!) into a temporary file,
which is then rewound and parsed by this parser, creating an entity object.
What happens then is determined by the OPTION:


<P>

<DL>
<DT><STRONG><A NAME="item_nest_or_1">NEST or 1

</A></STRONG><DD>
The contained message becomes a ``part'' of the <CODE>message/rfc822</CODE> entity, as though the <CODE>message/rfc822</CODE> were a special kind of <CODE>multipart</CODE> entity. This is the default behavior if the generic true value of ``1'' is
given.


<P>

<DT><STRONG><A NAME="item_replace">REPLACE

</A></STRONG><DD>
The contained message replaces the <CODE>message/rfc822</CODE> entity, as though the <CODE>message/rfc822</CODE> ``envelope'' never existed. Notice that, with this option, all the header
information in the <CODE>message/rfc822</CODE>
header is lost, so this option is <EM>not</EM>
 recommended.


<P>

</DL>
<EM>Thanks to Andreas Koenig for suggesting this method.</EM>





<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="parsing_messages">Parsing messages</A></H3>
<DL>
<DT><STRONG><A NAME="item_parse_data_data">parse_data DATA

</A></STRONG><DD>
<EM>Instance method.</EM>

Parse a MIME message that's already in-core. You may supply the DATA in any
of a number of ways...


<P>

<UL>
<LI><STRONG></STRONG>
<STRONG>A scalar</STRONG>
 which holds the message.


<P>

<LI><STRONG></STRONG>
<STRONG>A ref to a scalar</STRONG>
 which holds the message. This is an efficiency hack.


<P>

<LI><STRONG></STRONG>
<STRONG>A ref to an array of scalars.</STRONG>
  The array elements are simply joined to produce a scalar; no newlines are
inserted!


<P>

</UL>
Returns a <A HREF="Entity.html">MIME::Entity,</A> which may be a single
entity, or an arbitrarily-nested multipart entity. Returns undef on
failure.


<P>

<STRONG>Note:</STRONG>
 the storage of the body parts is not determined by this class, but by the
subclass you use to do the actual parsing. For efficiency, if you know
you'll be parsing a small amount of data, it is probably best to tell the
parser to store the parsed parts in core. For example, here's a short test
program, using <A HREF="Parser.html">MIME::Parser:</A>


<P>

<PRE>
        use MIME::Parser;
        
        my $msg = &lt;&lt;EOF;
    Content-type: text/html
    Content-transfer-encoding: 7bit
</PRE>

<P>

<PRE>
    &lt;H1&gt;Hello, world!&lt;/H1&gt;;
</PRE>

<P>

<PRE>
    EOF
        $parser = new MIME::Parser;
        $parser-&gt;output_to_core('ALL');
        $entity = $parser-&gt;parse_data($msg);
        $entity-&gt;print(\*STDOUT);
</PRE>

<P>

<DT><STRONG><A NAME="item_parse_two_headfile_bodyfile">parse_two HEADFILE, BODYFILE

</A></STRONG><DD>
<EM>Instance method.</EM>

Convenience front-end onto <CODE>read()</CODE>, intended for programs running under mail-handlers like <STRONG>deliver</STRONG>
, which splits the incoming mail message into a header file and a body
file.


<P>

Simply give this method the paths to the respective files.  
<EM>These must be pathnames:</EM>
 Perl ``open-able'' expressions won't work, since the pathnames are
shell-quoted for safety.


<P>

<STRONG>WARNING:</STRONG>
 it is assumed that, once the files are cat'ed together, there will be a
blank line separating the head part and the body part.


<P>

Returns the parsed entity, or undef on error.


<P>

<DT><STRONG><A NAME="item_read_instream">read INSTREAM

</A></STRONG><DD>
<EM>Instance method.</EM>

Takes a MIME-stream and splits it into its component entities, each of
which is decoded and placed in a separate file in the splitter's
<CODE>output_dir().</CODE>  


<P>

The INSTREAM can be given as a readable FileHandle, a globref'd filehandle
(like <CODE>\*STDIN</CODE>), or as <EM>any</EM>
 blessed object conforming to the <A HREF="IO.html">MIME::IO</A> (or IO::)
interface.


<P>

Returns a <A HREF="Entity.html">MIME::Entity,</A> which may be a single
entity, or an arbitrarily-nested multipart entity. Returns undef on
failure.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="writing_subclasses">WRITING SUBCLASSES</A></H2>
All you have to do to write a subclass is to provide or override the
following methods:


<P>

<DL>
<DT><STRONG><A NAME="item_init_args">init ARGS...

</A></STRONG><DD>
<EM>Instance method, private.</EM>

Initiallize the new parser object, with any args passed to <CODE>new()</CODE>.


<P>

You don't <EM>need</EM>
 to override this in your subclass. If you override it, however, make sure
you call the inherited method to init your parents!


<P>

<PRE>
    package MyParser;
    @ISA = qw(MIME::Parser);
    ...
    sub init {
	my $self = shift;
	$self-&gt;SUPER::init(@_);        # do my parent's init
	
	# ...my init stuff goes here...	
	
	$self;                         # return
    }
</PRE>

<P>

Should return the self object on success, and undef on failure.


<P>

<DT><STRONG><A NAME="item_new_body_for_head">new_body_for HEAD

</A></STRONG><DD>
<EM>Abstract instance method.</EM>

Based on the HEAD of a part we are parsing, return a new body object (any
desirable subclass of <A HREF="Body.html">MIME::Body)</A> for receiving
that part's data (both will be put into the ``entity'' object for that
part).


<P>

If you want the parser to do something other than write its parts out to
files, you should override this method in a subclass. For an example, see <STRONG><A HREF="Parser.html">MIME::Parser</A></STRONG>
.


<P>

<STRONG>Note:</STRONG>
 the reason that we don't use the ``interface'' mechanism for this is that
your choice of (1) which body class to use, and (2) how its <CODE>new()</CODE> method is invoked, may be very much based on the information in the header.


<P>

</DL>
You are of course free to override any other methods as you see fit, like <CODE>new</CODE>.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<STRONG>This is an abstract class.</STRONG>

If you actually want to parse a MIME stream, use one of the children of
this class, like the backwards-compatible <A
HREF="Parser.html">MIME::Parser.</A>


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="under_the_hood">Under the hood</A></H3>
RFC-1521 gives us the following BNF grammar for the body of a multipart
MIME message:


<P>

<PRE>
      multipart-body  := preamble 1*encapsulation close-delimiter epilogue
</PRE>

<P>

<PRE>
      encapsulation   := delimiter body-part CRLF
</PRE>

<P>

<PRE>
      delimiter       := &quot;--&quot; boundary CRLF 
                                   ; taken from Content-Type field.
                                   ; There must be no space between &quot;--&quot; 
                                   ; and boundary.
</PRE>

<P>

<PRE>
      close-delimiter := &quot;--&quot; boundary &quot;--&quot; CRLF 
                                   ; Again, no space by &quot;--&quot;
</PRE>

<P>

<PRE>
      preamble        := discard-text   
                                   ; to be ignored upon receipt.
</PRE>

<P>

<PRE>
      epilogue        := discard-text   
                                   ; to be ignored upon receipt.
</PRE>

<P>

<PRE>
      discard-text    := *(*text CRLF)
</PRE>

<P>

<PRE>
      body-part       := &lt;&quot;message&quot; as defined in RFC 822, with all 
                          header fields optional, and with the specified 
                          delimiter not occurring anywhere in the message 
                          body, either on a line by itself or as a substring 
                          anywhere.  Note that the semantics of a part 
                          differ from the semantics of a message, as 
                          described in the text.&gt;
</PRE>

<P>

From this we glean the following algorithm for parsing a MIME stream:


<P>

<PRE>
    PROCEDURE parse
    INPUT
        A FILEHANDLE for the stream.
        An optional end-of-stream OUTER_BOUND (for a nested multipart message).
    
    RETURNS
        The (possibly-multipart) ENTITY that was parsed.
        A STATE indicating how we left things: &quot;END&quot; or &quot;ERROR&quot;.
    
    BEGIN   
        LET OUTER_DELIM = &quot;--OUTER_BOUND&quot;.
        LET OUTER_CLOSE = &quot;--OUTER_BOUND--&quot;.
    
        LET ENTITY = a new MIME entity object.
        LET STATE  = &quot;OK&quot;.
    
        Parse the (possibly empty) header, up to and including the
        blank line that terminates it.   Store it in the ENTITY.
    
        IF the MIME type is &quot;multipart&quot;:
            LET INNER_BOUND = get multipart &quot;boundary&quot; from header.
            LET INNER_DELIM = &quot;--INNER_BOUND&quot;.
            LET INNER_CLOSE = &quot;--INNER_BOUND--&quot;.
    
            Parse preamble:
                REPEAT:
                    Read (and discard) next line
                UNTIL (line is INNER_DELIM) OR we hit EOF (error).
    
            Parse parts:
                REPEAT:
                    LET (PART, STATE) = parse(FILEHANDLE, INNER_BOUND).
                    Add PART to ENTITY.
                UNTIL (STATE != &quot;DELIM&quot;).
    
            Parse epilogue:
                REPEAT (to parse epilogue): 
                    Read (and discard) next line
                UNTIL (line is OUTER_DELIM or OUTER_CLOSE) OR we hit EOF
                LET STATE = &quot;EOF&quot;, &quot;DELIM&quot;, or &quot;CLOSE&quot; accordingly.
     
        ELSE (if the MIME type is not &quot;multipart&quot;):
            Open output destination (e.g., a file)
    
            DO:
                Read, decode, and output data from FILEHANDLE
            UNTIL (line is OUTER_DELIM or OUTER_CLOSE) OR we hit EOF.
            LET STATE = &quot;EOF&quot;, &quot;DELIM&quot;, or &quot;CLOSE&quot; accordingly.
    
        ENDIF
    
        RETURN (ENTITY, STATE).
    END
</PRE>

<P>

For reasons discussed in <A HREF="Entity.html">MIME::Entity,</A> we can't
just discard the ``discard text'': some mailers actually put data in the
preamble.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="questionable_practices">Questionable practices</A></H3>
<DL>
<DT><STRONG><A NAME="item_multipart_messages_are_always_re">Multipart messages are always read line-by-line 

</A></STRONG><DD>
Multipart document parts are read line-by-line, so that the encapsulation
boundaries may easily be detected. However, bad MIME composition agents
(for example, naive CGI scripts) might return multipart documents where the
parts are, say, unencoded bitmap files... and, consequently, where such
``lines'' might be veeeeeeeeery long indeed.


<P>

A better solution for this case would be to set up some form of state
machine for input processing. This will be left for future versions.


<P>

<DT><STRONG><A NAME="item_multipart_parts_read_into_temp_f">Multipart parts read into temp files before decoding

</A></STRONG><DD>
In my original implementation, the <A HREF="Decoder.html">MIME::Decoder</A>
classes had to be aware of encapsulation boundaries in multipart MIME
documents. While this decode-while-parsing approach obviated the need for
temporary files, it resulted in inflexible and complex decoder
implementations.


<P>

The revised implementation uses a temporary file (a la <CODE>tmpfile()</CODE>) during parsing to hold the <EM>encoded</EM>
 portion of the current MIME document or part. This file is deleted
automatically after the current part is decoded and the data is written to
the ``body stream'' object; you'll never see it, and should never need to
worry about it.


<P>

Some folks have asked for the ability to bypass this temp-file mechanism, I
suppose because they assume it would slow down their application. I
considered accomodating this wish, but the temp-file approach solves a lot
of thorny problems in parsing, and it also protects against hidden bugs in
user applications (what if you've directed the encoded part into a scalar,
and someone unexpectedly sends you a 6 MB tar file?). Finally, I'm just not
conviced that the temp-file use adds significant overhead.


<P>

<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_on_i">Fuzzing of CRLF and newline on input

</A></STRONG><DD>
RFC-1521 dictates that MIME streams have lines terminated by CRLF (<CODE>"\r\n"</CODE>). However, it is extremely likely that folks will want to parse MIME
streams where each line ends in the local newline character <CODE>"\n"</CODE> instead. 


<P>

An attempt has been made to allow the parser to handle both CRLF and
newline-terminated input.


<P>

<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_on_o">Fuzzing of CRLF and newline on output

</A></STRONG><DD>
The <CODE>"7bit"</CODE> and <CODE>"8bit"</CODE> decoders will decode both a <CODE>"\n"</CODE> and a <CODE>"\r\n"</CODE> end-of-line sequence into a <CODE>"\n"</CODE>.


<P>

The <CODE>"binary"</CODE> decoder (default if no encoding specified) still outputs stuff verbatim...
so a MIME message with CRLFs and no explicit encoding will be output as a
text file that, on many systems, will have an annoying ^M at the end of
each line... <EM>but this is as it should be</EM>
.


<P>

<DT><STRONG><A NAME="item_inability_to_handle_multipart_bo">Inability to handle multipart boundaries that contain newlines

</A></STRONG><DD>
First, let's get something straight: <EM>this is an evil, EVIL practice,</EM>

and is incompatible with RFC-1521... hence, it's not valid MIME.


<P>

If your mailer creates multipart boundary strings that contain newlines <EM>when they appear in the message body,</EM>
 give it two weeks notice and find another one. If your mail robot receives
MIME mail like this, regard it as syntactically incorrect MIME, which it
is.


<P>

Why do I say that? Well, in RFC-1521, the syntax of a boundary is given
quite clearly:


<P>

<PRE>
      boundary := 0*69&lt;bchars&gt; bcharsnospace
        
      bchars := bcharsnospace / &quot; &quot;
      
      bcharsnospace :=    DIGIT / ALPHA / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; / &quot;+&quot; /&quot;_&quot;
                   / &quot;,&quot; / &quot;-&quot; / &quot;.&quot; / &quot;/&quot; / &quot;:&quot; / &quot;=&quot; / &quot;?&quot;
</PRE>

<P>

All of which means that a valid boundary string <EM>cannot</EM>
 have newlines in it, and any newlines in such a string in the message
header are expected to be solely the result of <EM>folding</EM>
 the string (i.e., inserting to-be-removed newlines for readability and
line-shortening 
<EM>only</EM>
).


<P>

Yet, there is at least one brain-damaged user agent out there that composes
mail like this:


<P>

<PRE>
      MIME-Version: 1.0
      Content-type: multipart/mixed; boundary=&quot;----ABC-
       123----&quot;
      Subject: Hi... I'm a dork!
      
      This is a multipart MIME message (yeah, right...)
      
      ----ABC-
       123----
      
      Hi there! 
</PRE>

<P>

We have <EM>got</EM>
 to discourage practices like this (and the recent file upload idiocy where
binary files that are part of a multipart MIME message aren't
base64-encoded) if we want MIME to stay relatively simple, and MIME parsers
to be relatively robust. 


<P>

<EM>Thanks to Andreas Koenig for bringing a baaaaaaaaad user agent to my
attention.</EM>





<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="warnings">WARNINGS</A></H2>
<DL>
<DT><STRONG><A NAME="item_binmode">binmode

</A></STRONG><DD>
New, untested <A HREF="#item_binmode">binmode</A> calls were added in
module version 1.11... if <A HREF="#item_binmode">binmode</A> is <EM>not</EM>
 a NOOP on your system, please pay careful attention to your output, and
report <EM>any</EM>
 anomalies.  
<EM>It is possible that ``make test'' will fail on such systems,</EM>
 
since some of the tests involve checking the sizes of the output files.
That doesn't necessarily indicate a problem.


<P>

<STRONG>If anyone</STRONG>
 wants to test out this package's handling of both binary and textual email
on a system where <A HREF="#item_binmode">binmode</A> is not a NOOP, I
would be most grateful. If stuff breaks, send me the pieces (including the
original email that broke it, and at the very least a description of how
the output was screwed up).


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR</A></H2>
Copyright (c) 1996 by Eryq / <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A>


<P>

All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="version">VERSION</A></H2>
$Revision: 3.202 $ $Date: 1997/01/19 01:34:53 $


<P>

</BODY>
</HTML>
