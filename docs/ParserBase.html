    <HTML>

    <HEAD>
    <TITLE>MIME::ParserBase</TITLE>
    </HEAD>

    <BODY>

    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><A HREF="MIME-tools.html">Home</A></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Body.html">MIME::Body</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Decoder.html">MIME::Decoder</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Entity.html">MIME::Entity</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Head.html">MIME::Head</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1 COLOR=#B00020>MIME::ParserBase</FONT></B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#300080>MIME::<BR>ParserBase</FONT></B></H1>
	    <img src="mime-sm.gif" alt="MIME">
	    <P><FONT SIZE=+1 COLOR=#B00020><I>It's MIME time! *</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
	<LI><A HREF="#writing_subclasses">WRITING SUBCLASSES</A>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#under_the_hood">Under the hood</A>
		<LI><A HREF="#questionable_practices">Questionable practices</A>
		</UL>
	<LI><A HREF="#warnings">WARNINGS</A>
	<LI><A HREF="#see_also">SEE ALSO</A>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#version">VERSION</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
<A HREF="ParserBase.html">MIME::ParserBase</A> - abstract class for parsing
MIME mail


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
This is an <EM>abstract</EM>
 class; however, here's how one of its 
<EM>concrete subclasses</EM>
 is used:


<P>

<PRE>
    use MIME::Parser;
    
    # Create a new parser object:
    my $parser = new MIME::Parser;
    
    # Parse an input stream:
    $entity = $parser-&gt;read(\*STDIN) or die &quot;couldn't parse MIME stream&quot;;
    
    # Congratulations: you now have a (possibly multipart) MIME entity!
    $entity-&gt;dump_skeleton;          # for debugging 
</PRE>

<P>

There are also some convenience methods:


<P>

<PRE>
    # Parse already-split input (as &quot;deliver&quot; would give it to you):
    $entity = $parser-&gt;parse_two(&quot;msg.head&quot;, &quot;msg.body&quot;)
          || die &quot;couldn't parse MIME files&quot;;
</PRE>

<P>

In case a parse fails, it's nice to know who sent it to us. So...


<P>

<PRE>
    # Parse an input stream:
    $entity = $parser-&gt;read(\*STDIN);
    if (!$entity) {           # oops!
	my $decapitated = $parser-&gt;last_head;    # last top-level head
    }
</PRE>

<P>

You can also alter the behavior of the parser:    


<P>

<PRE>
    # Parse contained &quot;message/rfc822&quot; objects as nested MIME streams:
    $parser-&gt;parse_nested_messages(1);
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
Where it all begins.  


<P>

This is the class that contains all the knowledge for <EM>parsing</EM>
 MIME streams. It's an abstract class, containing no methods governing the <EM>output</EM>
 of the parsed entities: such methods belong in the concrete subclasses.


<P>

You can inherit from this class to create your own subclasses that parse
MIME streams into <A HREF="Entity.html">MIME::Entity</A> objects. One such
subclass, 
<STRONG><A HREF="Parser.html">MIME::Parser</A></STRONG>
, is already provided in this kit.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="public_interface">PUBLIC INTERFACE</A></H2>
<DL>
<DT><STRONG><A NAME="item_new_args">new ARGS...

</A></STRONG><DD>
<EM>Class method.</EM>

Create a new parser object. Passes any subsequent arguments onto the <CODE>init()</CODE> method.


<P>

Once you create a parser object, you can then set up various parameters
before doing the actual parsing. Here's an example using one of our
concrete subclasses:


<P>

<PRE>
    my $parser = new MIME::Parser;
    $parser-&gt;output_dir(&quot;/tmp&quot;);
    $parser-&gt;output_prefix(&quot;msg1&quot;);
    my $entity = $parser-&gt;read(\*STDIN);
</PRE>

<P>

<DT><STRONG><A NAME="item_init_args">init ARGS...

</A></STRONG><DD>
<EM>Instance method.</EM>

Initiallize the new parser object, with any args passed to <CODE>new()</CODE>.


<P>

If you override this in a subclass, make sure you call the inherited method
to init your parents!


<P>

<PRE>
    package MyParser;
    @ISA = qw(MIME::Parser);
    ...
    sub init {
	my $self = shift;
	$self-&gt;SUPER::init(@_);        # do my parent's init
	
	# ...my init stuff goes here...	
	
	$self;                         # return
    }
</PRE>

<P>

Should return the self object on success, and undef on failure.


<P>

<DT><STRONG><A NAME="item_interface_rolevalue">interface ROLE,[VALUE]

</A></STRONG><DD>
<EM>Instance method.</EM>

During parsing, the parser normally creates instances of certain classes,
like <A HREF="Entity.html">MIME::Entity.</A> However, you may want to
create a parser subclass that uses your own experimental head, entity, etc.
classes (for example, your ``head'' class may provide some additional
MIME-field-oriented methods).


<P>

If so, then this is the method that your subclass should invoke during
init. Use it like this:


<P>

<PRE>
    package MyParser;
    @ISA = qw(MIME::Parser);
    ...
    sub init {
	my $self = shift;
	$self-&gt;SUPER::init(@_);        # do my parent's init
        $self-&gt;interface(ENTITY_CLASS =&gt; 'MIME::MyEntity');
	$self-&gt;interface(HEAD_CLASS   =&gt; 'MIME::MyHead');
	$self;                         # return
    }
</PRE>

<P>

With no VALUE, returns the VALUE currently associated with that ROLE.


<P>

<DT><STRONG><A NAME="item_last_head">last_head

</A></STRONG><DD>
Return the top-level MIME header of the last stream we attempted to parse.
This is useful for replying to people who sent us bad MIME messages.


<P>

<PRE>
    # Parse an input stream:
    $entity = $parser-&gt;read(\*STDIN);
    if (!$entity) {           # oops!
	my $decapitated = $parser-&gt;last_head;    # last top-level head
    }
</PRE>

<P>

<DT><STRONG><A NAME="item_parse_nested_messages_option">parse_nested_messages OPTION

</A></STRONG><DD>
Some MIME messages will contain a part of type <CODE>message/rfc822</CODE>: literally, the text of an embedded mail message. The normal behavior is
to save such a message just as if it were a <CODE>text/plain</CODE> 
document. However, you can change this: before parsing, invoke this method
with the OPTION you want:


<P>

<STRONG>If OPTION is false,</STRONG>
 the normal behavior will be used.


<P>

<STRONG>If OPTION is true,</STRONG>
 the body of the <CODE>message/rfc822</CODE> part is decoded (after all, it might be encoded!) into a temporary file,
which is then rewound and parsed by this parser, creating an entity object.
What happens then is determined by the OPTION:


<P>

<DL>
<DT><STRONG><A NAME="item_nest_or_1">NEST or 1

</A></STRONG><DD>
The contained message becomes a ``part'' of the <CODE>message/rfc822</CODE> entity, as though the <CODE>message/rfc822</CODE> were a special kind of <CODE>multipart</CODE> entity. This is the default behavior if the generic true value of ``1'' is
given.


<P>

<DT><STRONG><A NAME="item_replace">REPLACE

</A></STRONG><DD>
The contained message replaces the <CODE>message/rfc822</CODE> entity, as though the <CODE>message/rfc822</CODE> ``envelope'' never existed. Notice that, with this option, all the header
information in the <CODE>message/rfc822</CODE>
header is lost, so this option is <EM>not</EM>
 recommended.


<P>

</DL>
<EM>Thanks to Andreas Koenig for suggesting this method.</EM>





<P>

<DT><STRONG><A NAME="item_parse_two_headfile_bodyfile">parse_two HEADFILE BODYFILE

</A></STRONG><DD>
Convenience front-end onto <CODE>read()</CODE>, intended for programs running under mail-handlers like <STRONG>deliver</STRONG>
, which splits the incoming mail message into a header file and a body
file.


<P>

Simply give this method the paths to the respective files.  
<EM>These must be pathnames:</EM>
 Perl ``open-able'' expressions won't work, since the pathnames are
shell-quoted for safety.


<P>

<STRONG>WARNING:</STRONG>
 it is assumed that, once the files are cat'ed together, there will be a
blank line separating the head part and the body part.


<P>

<DT><STRONG><A NAME="item_read_filehandle">read FILEHANDLE

</A></STRONG><DD>
Takes a MIME-stream and splits it into its component entities, each of
which is decoded and placed in a separate file in the splitter's
<CODE>output_dir().</CODE>  


<P>

The stream should be given as a FileHandle, or at least a glob ref to a
readable FILEHANDLE; e.g., <CODE>\*STDIN</CODE>.


<P>

Returns a <A HREF="Entity.html">MIME::Entity,</A> which may be a single
entity, or an arbitrarily-nested multipart entity. Returns undef on
failure.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="writing_subclasses">WRITING SUBCLASSES</A></H2>
All you have to do to write a subclass is to provide the following methods:


<P>

<DL>
<DT><STRONG><A NAME="item_new_body_for_head">new_body_for HEAD

</A></STRONG><DD>
<EM>Abstract method.</EM>

Based on the HEAD of a part we are parsing, return a new body object (any
desirable subclass of <A HREF="Body.html">MIME::Body)</A> for receiving
that part's data (both will be put into the ``entity'' object for that
part).


<P>

If you want the parser to do something other than write its parts out to
files, you should override this method in a subclass. For an example, see <STRONG><A HREF="Parser.html">MIME::Parser</A></STRONG>
.


<P>

<STRONG>Note:</STRONG>
 the reason that we don't use the ``interface'' mechanism for this is that
your choice of (1) which body class to use, and (2) how its <CODE>new()</CODE> method is invoked, may be very much based on the information in the header.


<P>

</DL>
You are of course free to override any other methods as you see fit, like <CODE>new</CODE>.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<STRONG>This is an abstract class.</STRONG>

If you actually want to parse a MIME stream, use one of the children of
this class, like the backwards-compatible <A
HREF="Parser.html">MIME::Parser.</A>


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="under_the_hood">Under the hood</A></H3>
RFC-1521 gives us the following BNF grammar for the body of a multipart
MIME message:


<P>

<PRE>
      multipart-body  := preamble 1*encapsulation close-delimiter epilogue
</PRE>

<P>

<PRE>
      encapsulation   := delimiter body-part CRLF
</PRE>

<P>

<PRE>
      delimiter       := &quot;--&quot; boundary CRLF 
                                   ; taken from Content-Type field.
                                   ; There must be no space between &quot;--&quot; 
                                   ; and boundary.
</PRE>

<P>

<PRE>
      close-delimiter := &quot;--&quot; boundary &quot;--&quot; CRLF 
                                   ; Again, no space by &quot;--&quot;
</PRE>

<P>

<PRE>
      preamble        := discard-text   
                                   ; to be ignored upon receipt.
</PRE>

<P>

<PRE>
      epilogue        := discard-text   
                                   ; to be ignored upon receipt.
</PRE>

<P>

<PRE>
      discard-text    := *(*text CRLF)
</PRE>

<P>

<PRE>
      body-part       := &lt;&quot;message&quot; as defined in RFC 822, with all 
                          header fields optional, and with the specified 
                          delimiter not occurring anywhere in the message 
                          body, either on a line by itself or as a substring 
                          anywhere.  Note that the semantics of a part 
                          differ from the semantics of a message, as 
                          described in the text.&gt;
</PRE>

<P>

From this we glean the following algorithm for parsing a MIME stream:


<P>

<PRE>
    PROCEDURE parse
    INPUT
        A FILEHANDLE for the stream.
        An optional end-of-stream OUTER_BOUND (for a nested multipart message).
    
    RETURNS
        The (possibly-multipart) ENTITY that was parsed.
        A STATE indicating how we left things: &quot;END&quot; or &quot;ERROR&quot;.
    
    BEGIN   
        LET OUTER_DELIM = &quot;--OUTER_BOUND&quot;.
        LET OUTER_CLOSE = &quot;--OUTER_BOUND--&quot;.
    
        LET ENTITY = a new MIME entity object.
        LET STATE  = &quot;OK&quot;.
    
        Parse the (possibly empty) header, up to and including the
        blank line that terminates it.   Store it in the ENTITY.
    
        IF the MIME type is &quot;multipart&quot;:
            LET INNER_BOUND = get multipart &quot;boundary&quot; from header.
            LET INNER_DELIM = &quot;--INNER_BOUND&quot;.
            LET INNER_CLOSE = &quot;--INNER_BOUND--&quot;.
    
            Parse preamble:
                REPEAT:
                    Read (and discard) next line
                UNTIL (line is INNER_DELIM) OR we hit EOF (error).
    
            Parse parts:
                REPEAT:
                    LET (PART, STATE) = parse(FILEHANDLE, INNER_BOUND).
                    Add PART to ENTITY.
                UNTIL (STATE != &quot;DELIM&quot;).
    
            Parse epilogue:
                REPEAT (to parse epilogue): 
                    Read (and discard) next line
                UNTIL (line is OUTER_DELIM or OUTER_CLOSE) OR we hit EOF
                LET STATE = &quot;EOF&quot;, &quot;DELIM&quot;, or &quot;CLOSE&quot; accordingly.
     
        ELSE (if the MIME type is not &quot;multipart&quot;):
            Open output destination (e.g., a file)
    
            DO:
                Read, decode, and output data from FILEHANDLE
            UNTIL (line is OUTER_DELIM or OUTER_CLOSE) OR we hit EOF.
            LET STATE = &quot;EOF&quot;, &quot;DELIM&quot;, or &quot;CLOSE&quot; accordingly.
    
        ENDIF
    
        RETURN (ENTITY, STATE).
    END
</PRE>

<P>

For reasons discussed in <A HREF="Entity.html">MIME::Entity,</A> we can't
just discard the ``discard text'': some mailers actually put data in the
preamble.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="questionable_practices">Questionable practices</A></H3>
<DL>
<DT><STRONG><A NAME="item_multipart_messages_are_always_re">Multipart messages are always read line-by-line 

</A></STRONG><DD>
Multipart document parts are read line-by-line, so that the encapsulation
boundaries may easily be detected. However, bad MIME composition agents
(for example, naive CGI scripts) might return multipart documents where the
parts are, say, unencoded bitmap files... and, consequently, where such
``lines'' might be veeeeeeeeery long indeed.


<P>

A better solution for this case would be to set up some form of state
machine for input processing. This will be left for future versions.


<P>

<DT><STRONG><A NAME="item_multipart_parts_read_into_temp_f">Multipart parts read into temp files before decoding

</A></STRONG><DD>
In my original implementation, the <A HREF="Decoder.html">MIME::Decoder</A>
classes had to be aware of encapsulation boundaries in multipart MIME
documents. While this decode-while-parsing approach obviated the need for
temporary files, it resulted in inflexible and complex decoder
implementations.


<P>

The revised implementation uses a temporary file (a la <CODE>tmpfile()</CODE>) during parsing to hold the <EM>encoded</EM>
 portion of the current MIME document or part. This file is deleted
automatically after the current part is decoded and the data is written to
the ``body stream'' object; you'll never see it, and should never need to
worry about it.


<P>

Some folks have asked for the ability to bypass this temp-file mechanism, I
suppose because they assume it would slow down their application. I
considered accomodating this wish, but the temp-file approach solves a lot
of thorny problems in parsing, and it also protects against hidden bugs in
user applications (what if you've directed the encoded part into a scalar,
and someone unexpectedly sends you a 6 MB tar file?). Finally, I'm just not
conviced that the temp-file use adds significant overhead.


<P>

<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_on_i">Fuzzing of CRLF and newline on input

</A></STRONG><DD>
RFC-1521 dictates that MIME streams have lines terminated by CRLF (<CODE>"\r\n"</CODE>). However, it is extremely likely that folks will want to parse MIME
streams where each line ends in the local newline character <CODE>"\n"</CODE> instead. 


<P>

An attempt has been made to allow the parser to handle both CRLF and
newline-terminated input.


<P>

<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_on_o">Fuzzing of CRLF and newline on output

</A></STRONG><DD>
The <CODE>"7bit"</CODE> and <CODE>"8bit"</CODE> decoders will decode both a <CODE>"\n"</CODE> and a <CODE>"\r\n"</CODE> end-of-line sequence into a <CODE>"\n"</CODE>.


<P>

The <CODE>"binary"</CODE> decoder (default if no encoding specified) still outputs stuff verbatim...
so a MIME message with CRLFs and no explicit encoding will be output as a
text file that, on many systems, will have an annoying ^M at the end of
each line... <EM>but this is as it should be</EM>
.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="warnings">WARNINGS</A></H2>
<DL>
<DT><STRONG><A NAME="item_binmode">binmode

</A></STRONG><DD>
New, untested <A HREF="#item_binmode">binmode</A> calls were added in
module version 1.11... if <A HREF="#item_binmode">binmode</A> is <EM>not</EM>
 a NOOP on your system, please pay careful attention to your output, and
report <EM>any</EM>
 anomalies.  
<EM>It is possible that ``make test'' will fail on such systems,</EM>
 
since some of the tests involve checking the sizes of the output files.
That doesn't necessarily indicate a problem.


<P>

<STRONG>If anyone</STRONG>
 wants to test out this package's handling of both binary and textual email
on a system where <A HREF="#item_binmode">binmode</A> is not a NOOP, I
would be most grateful. If stuff breaks, send me the pieces (including the
original email that broke it, and at the very least a description of how
the output was screwed up).


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="see_also">SEE ALSO</A></H2>
<A HREF="Decoder.html">MIME::Decoder,</A> <A
HREF="Entity.html">MIME::Entity,</A> <A HREF="Head.html">MIME::Head,</A> <A
HREF="Parser.html">MIME::Parser.</A>


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR</A></H2>
Copyright (c) 1996 by Eryq / <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A>


<P>

All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="version">VERSION</A></H2>
$Revision: 1.1 $ $Date: 1996/10/18 06:52:28 $


<P>

    <P>
    <HR>       
    <FONT COLOR=#F00000>*</FONT>
    <FONT SIZE=-1>
    Artwork and slogan from Warner Bros' "Animaniacs". 
    Neither this code nor its author are connected with or
    endorsed by Warner Bros. in any way. Narf. Poit. 
    </FONT>
    </BODY>

    </HTML>
