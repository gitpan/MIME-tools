<HTML>
<HEAD>
  <TITLE>MIME::Words</TITLE>
</HEAD>
<BODY 
       bgcolor="#FFFFFF" link="#BE1B58" vlink="#8C337C" alink="#F28EAA">
<A HREF="http://www.zeegee.com" TARGET="_top"><IMG SRC="icons/zeegee.gif" ALT="ZeeGee Software" ALIGN="RIGHT" BORDER="0"></A><A NAME="__TOP__"><H1>MIME::Words</H1>
</A>
<P><B>This module is <FONT COLOR="#990000">BETA</FONT> code, which means that the interfaces are fairly stable BUT it has not been out in the community long enough to guarantee much testing. Use with caution! Please report any errors back to <A HREF="mailto:eryq@zeegee.com">eryq@zeegee.com</A> as soon as you can.</B><UL>
<LI> <A HREF="#NAME">NAME</A>
<LI> <A HREF="#SYNOPSIS">SYNOPSIS</A>
<LI> <A HREF="#DESCRIPTION">DESCRIPTION</A>
<LI> <A HREF="#PUBLIC_INTERFACE">PUBLIC INTERFACE</A>
<LI> <A HREF="#NOTES">NOTES</A>
<LI> <A HREF="#AUTHOR">AUTHOR</A>
<LI> <A HREF="#VERSION">VERSION</A>
</UL>
</A>

<P><HR>
<A NAME="NAME"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NAME</H2></A>


<P>MIME::Words - deal with RFC-1522 encoded words



<P><HR>
<A NAME="SYNOPSIS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> SYNOPSIS</H2></A>

<PRE>
    use MIME::Words qw(:all);   
     
    ### Decode the string into another string, forgetting the charsets:
    $decoded = decode_mimewords(
          'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;',
          );
    
    ### Split string into array of decoded [DATA,CHARSET] pairs:
    @decoded = decode_mimewords(
          'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;',
          );
     
    ### Encode a single unsafe word:
    $encoded = encode_mimeword(&quot;\xABFran\xE7ois\xBB&quot;);
    
    ### Encode a string, trying to find the unsafe words inside it: 
    $encoded = encode_mimewords(&quot;Me and \xABFran\xE7ois\xBB in town&quot;);
</PRE>


<P><HR>
<A NAME="DESCRIPTION"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> DESCRIPTION</H2></A>


<P>Fellow Americans, you probably won't know what the hell this module
is for.  Europeans, Russians, et al, you probably do.  <CODE>:-)</CODE>. 


<P>For example, here's a valid MIME header you might get:

<PRE>
      From: =?US-ASCII?Q?Keith_Moore?= &lt;moore@cs.utk.edu&gt;
      To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;
      CC: =?ISO-8859-1?Q?Andr=E9_?= Pirard &lt;PIRARD@vm1.ulg.ac.be&gt;
      Subject: =?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
       =?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
       =?US-ASCII?Q?.._cool!?=
</PRE>

<P>The fields basically decode to (sorry, I can only approximate the
Latin characters with 7 bit sequences /o and 'e):

<PRE>
      From: Keith Moore &lt;moore@cs.utk.edu&gt;
      To: Keld J/orn Simonsen &lt;keld@dkuug.dk&gt;
      CC: Andr'e  Pirard &lt;PIRARD@vm1.ulg.ac.be&gt;
      Subject: If you can read this you understand the example... cool!
</PRE>


<P><HR>
<A NAME="PUBLIC_INTERFACE"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> PUBLIC INTERFACE</H2></A>



<DL>
<P><DT><B><A NAME="item:decode_mimewords">decode_mimewords ENCODED, [OPTS...]</A></B></DT>
<DD>
Go through the string looking for RFC-1522-style &quot;Q&quot;
(quoted-printable, sort of) or &quot;B&quot; (base64) encoding, and decode them.


<P><B>In an array context,</B> splits the ENCODED string into a list of decoded 
<CODE>[DATA, CHARSET]</CODE> pairs, and returns that list.  Unencoded 
data are returned in a 1-element array <CODE>[DATA]</CODE>, giving an effective 
CHARSET of <CODE>undef</CODE>.

<PRE>
    $enc = '=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;';
    foreach (decode_mimewords($enc)) {
        print &quot;&quot;, ($_[1] || 'US-ASCII'), &quot;: &quot;, $_[0], &quot;\n&quot;;
    }
</PRE>

<P><B>In a scalar context,</B> joins the &quot;data&quot; elements of the above list together,
and returns that.  This is information-lossy, but if you know that
all charsets in the ENCODED string are identical, it might be useful to you.


<P>In the event of a syntax error, $@ will be set to a description 
of the error, but parsing will continue as best as possible (so as to
get <I>something</I> back when decoding headers).
$@ will be false if no error was detected.


<P>Any arguments past the ENCODED string are taken to define a hash of options:



<DL>
<P><DT><B><A NAME="item:Field">Field</A></B></DT>
<DD>
Name of the mail field this string came from.  <I>Currently ignored.</I>

</DL>

<P><DT><B><A NAME="item:encode_mimeword">encode_mimeword RAW, [ENCODING], [CHARSET]</A></B></DT>
<DD>
Encode a single RAW &quot;word&quot; that has unsafe characters.

<PRE>
    ### Encode &quot;&lt;&lt;Franc,ois&gt;&gt;&quot;:
    $encoded = encode_mimeword(&quot;\xABFran\xE7ois\xBB&quot;);
</PRE>

<P>You may specify the ENCODING (<CODE>&quot;Q&quot;</CODE> or <CODE>&quot;B&quot;</CODE>), which defaults to <CODE>&quot;Q&quot;</CODE>.
You may specify the CHARSET, which defaults to <CODE>iso-8859-1</CODE>.
    
The &quot;word&quot; will be encoded in its entirety.

<P><DT><B><A NAME="item:encode_mimewords">encode_mimewords RAW, [OPTS]</A></B></DT>
<DD>
Given a RAW string, try to find and encode all &quot;unsafe&quot; sequences 
of characters:

<PRE>
    ### Encode a string with some unsafe &quot;words&quot;:
    $encoded = encode_mimewords(&quot;Me and \xABFran\xE7ois\xBB&quot;);
</PRE>

<P>Returns the encoded string.
Any arguments past the RAW string are taken to define a hash of options:



<DL>
<P><DT><B><A NAME="item:Charset">Charset</A></B></DT>
<DD>
Encode all unsafe stuff with this charset.  Default is 'ISO-8859-1',
a.k.a. &quot;Latin-1&quot;.

<P><DT><B><A NAME="item:Encoding">Encoding</A></B></DT>
<DD>
The encoding to use, <CODE>&quot;q&quot;</CODE> or <CODE>&quot;b&quot;</CODE>.  The default is <CODE>&quot;q&quot;</CODE>.

<P><DT><B><A NAME="item:Field">Field</A></B></DT>
<DD>
Name of the mail field this string will be used in.  <I>Currently ignored.</I>

</DL>


<P><B>Warning:</B> this is a quick-and-dirty solution, intended for character
sets which overlap ASCII.  You may want to roll your own variant,
using <CODE>encoded_mimeword()</CODE>, for your application.

</DL>



<P><HR>
<A NAME="NOTES"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NOTES</H2></A>


<P>Exports its principle functions by default, in keeping with 
MIME::Base64 and MIME::QuotedPrint.



<P><HR>
<A NAME="AUTHOR"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> AUTHOR</H2></A>


<P>Eryq (<I><FILE><A HREF="mailto:eryq@zeegee.com">eryq@zeegee.com</A></FILE></I>), ZeeGee Software Inc (<I><FILE><A HREF="http://www.zeegee.com">http://www.zeegee.com</A></FILE></I>).


<P>All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.


<P>Thanks also to...

<PRE>
      Kent Boortz        For providing the idea, and the baseline 
                         RFC-1522-decoding code!
      KJJ at PrimeNet    For requesting that this be split into
                         its own module.
      Stephane Barizien  For reporting a nasty bug.
</PRE>


<P><HR>
<A NAME="VERSION"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> VERSION</H2></A>


<P>$Revision: 5.104 $ $Date: 2000/05/23 05:36:20 $

<P><HR>
<ADDRESS><FONT SIZE=-1>
Generated Wed May 24 01:13:58 2000 by cvu_pod2html
</FONT></ADDRESS>
</BODY>
</HTML>
