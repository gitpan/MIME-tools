<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Generated by pod2coolhtml 1.101
  -- Using Pod::CoolHTML 1.104 , (C) 1997 by Eryq (eryq@enteract.com).
  --
  -- DO NOT EDIT THIS HTML FILE! All your changes will be lost.
  -- Edit the POD or Perl file that was used to create it.
  -->
<HTML>

<HEAD>
<TITLE>MIME::Parser</TITLE>
</HEAD>
<BODY LINK=#C00000 ALINK=#FF2020 VLINK=#900000>
<A NAME="__top"> </A><CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><FONT SIZE=+1>
<A HREF="Tools.pm.html">MIME::Tools</A></FONT></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Body.pm.html">MIME::Body</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Decoder.pm.html">MIME::Decoder</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Entity.pm.html">MIME::Entity</A></SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Head.pm.html">MIME::Head</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="IO.pm.html">MIME::IO</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Latin1.pm.html">MIME::Latin1</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Parser</SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="ParserBase.pm.html">MIME::ParserBase</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="ToolUtils.pm.html">MIME::ToolUtils</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Tools.pm.html">MIME::Tools</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Words.pm.html">MIME::Words</A></SMALL></B></TD>
</TABLE></CENTER>

<P><TABLE WIDTH="100%">

<TR VALIGN="TOP"><TD ALIGN="LEFT"><CENTER>
<H1><FONT SIZE=7 COLOR=#600020><B>MIME::<BR>Parser</B></FONT></H1><IMG SRC="mime-sm.gif" ALT="MIME!"></CENTER>
<TD>
<UL>
<LI><A HREF="#name">NAME</A>
</LI><LI><A HREF="#synopsis">SYNOPSIS</A>
</LI><LI><A HREF="#description">DESCRIPTION</A>
</LI><LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
</LI><LI><A HREF="#writing_subclasses">WRITING SUBCLASSES</A>
</LI><LI><A HREF="#author">AUTHOR</A>
</LI><LI><A HREF="#version">VERSION</A>
</LI></UL>

</TABLE>

<P><HR>
<A NAME="name">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NAME</FONT></H1>
</A>


<P>
MIME::Parser - split MIME mail into decoded components


<P><HR>
<A NAME="synopsis">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
SYNOPSIS</FONT></H1>
</A>


<P>
<PRE>    # Create a new parser object:
    my &#36;parser = new MIME::Parser;</PRE>



<P>
<PRE>    # Set up output directory for files:
    &#36;parser-&gt;output_dir(&quot;&#36;ENV{HOME}/mimemail&quot;);</PRE>



<P>
<PRE>    # Set up the prefix for files with auto-generated names:
    &#36;parser-&gt;output_prefix(&quot;part&quot;);</PRE>



<P>
<PRE>    # If content length is &lt;= 20000 bytes, store each msg as in-core scalar;
    # Else, write to a disk file (the default action):
    &#36;parser-&gt;output_to_core(20000);</PRE>



<P>
<PRE>    # Parse an input stream:
    &#36;entity = &#36;parser-&gt;read(\*STDIN) or die &quot;couldn't parse MIME stream&quot;;</PRE>



<P>
<PRE>    # Congratulations: you now have a (possibly multipart) MIME entity!
    &#36;entity-&gt;dump_skeleton;          # for debugging </PRE>



<P>
Shortcuts:


<P>
<PRE>    # Create a new parser object, and set some properties:
    my &#36;parser = new MIME::Parser output_dir     =&gt; &quot;&#36;ENV{HOME}/mimemail&quot;,
                                  output_prefix  =&gt; &quot;part&quot;,
                                  output_to_core =&gt; 20000;</PRE>



<P><HR>
<A NAME="description">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
DESCRIPTION</FONT></H1>
</A>


<P>
A subclass of MIME::ParserBase, providing one useful way to parse MIME
streams and obtain MIME::Entity objects.  This particular parser class
outputs the different parts as files on disk, in the directory of your
choice.


<P>
If you don't like the way files are named... it's object-oriented 
and subclassable.  If you want to do something <I>really</I> different,
perhaps you want to subclass MIME::ParserBase instead.


<P><HR>
<A NAME="public_interface">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
PUBLIC INTERFACE</FONT></H1>
</A>

<DL>
<P><DT><B><A NAME="init">init PARAMHASM</A></B><DD>

Initiallize a new MIME::Parser object.  This is automatically sent to
a new object; the PARAMHASH can contain the following...

<DL>
<P><DT><B><A NAME="output_dir">output_dir</A></B><DD>

The value is passed to <A HREF="#output_dir">output_dir()</A>.


<P><DT><B><A NAME="output_prefix">output_prefix</A></B><DD>

The value is passed to <A HREF="#output_prefix">output_prefix()</A>.


<P><DT><B><A NAME="output_to_core">output_to_core</A></B><DD>

The value is passed to <A HREF="#output_to_core">output_to_core()</A>.

</DL>


<P>
For example:


<P>
<PRE>   &#36;p = new MIME::Parser output_dir =&gt; &quot;/tmp/mime&quot;,
                         output_to_core =&gt; 'ALL';</PRE>



<P><DT><B><A NAME="evil_filename">evil_filename FILENAME</A></B><DD>

<I>Instance method.</I>
Is this an evil filename?  It is if it contains any <CODE>&quot;/&quot;</CODE> characters,
or if it's <CODE>&quot;.&quot;</CODE>, <CODE>&quot;..&quot;</CODE>, or empty.


<P>
Override this method in a subclass if you just want to change which 
externally-provided filenames are allowed, and which are not.  Like this:


<P>
<PRE>     package MIME::MyParser;</PRE>



<P>
<PRE>     use MIME::Parser;
     @ISA = qw(MIME::Parser);</PRE>



<P>
<PRE>     sub evil_filename {
         my (&#36;self, &#36;name) = @_;
         return (&#36;name !~ /^[a-z\d][a-z\d\._-]*&#36;/i);   # only simple names ok
     }</PRE>



<P>
<B>Note:</B> This method used to be a lot stricter, but it unnecessailry
inconvenienced users on non-ASCII systems.  That has been changed in 4.x.


<P>
<I>Thanks to Andrew Pimlott for finding a real dumb bug in the original
version.  Thanks to Nickolay Saukh for noting that evil is in the 
eye of the beholder.</I>


<P><DT><B><A NAME="new_body_for">new_body_for HEAD</A></B><DD>

<I>Instance method.</I>
Based on the HEAD of a part we are parsing, return a new
body object (any desirable subclass of MIME::Body) for
receiving that part's data.


<P>
The default behavior is to examine the HEAD for a recommended
filename (generating a random one if none is available), 
and create a new MIME::Body::File on that filename in 
the parser's current <CODE>output_dir()</CODE>.


<P>
If you use the <CODE>output_to_core</CODE> method (q.v.) before parsing, 
you can force this method to output some or all or a message's 
parts to in-core data structures, based on their size.


<P>
If you want the parser to do something else entirely, you should 
override this method in a subclass.


<P><DT><B><A NAME="output_dir">output_dir [DIRECTORY]</A></B><DD>

<I>Instance method.</I>
Get/set the output directory for the parsing operation.
This is the directory where the extracted and decoded body parts will go.
The default is <CODE>&quot;.&quot;</CODE>.


<P>
If <CODE>DIRECTORY</CODE> <I>is not</I> given, the current output directory is returned.
If <CODE>DIRECTORY</CODE> <I>is</I> given, the output directory is set to the new value,
and the previous value is returned.


<P>
<B>Note:</B> this is used by the <CODE>output_path()</CODE> method in this class.
It should also be used by subclasses, but if a subclass decides to 
output parts in some completely different manner, this method may 
of course be completely ignored.


<P><DT><B><A NAME="output_path">output_path HEAD</A></B><DD>

<I>Instance method.</I>
Given a MIME head for a file to be extracted, come up with a good
output pathname for the extracted file.


<P>
The &quot;directory&quot; portion of the returned path will be the <CODE>output_dir()</CODE>, 
and the &quot;filename&quot; portion will be determined as follows:

<UL>

<P><LI>If the MIME header contains a recommended filename, and it is
<I>not</I> judged to be &quot;evil&quot; (evil filenames are ones which contain
things like &quot;/&quot; or &quot;..&quot; or non-ASCII characters), then that 
filename will be used.


<P><LI>If the MIME header contains a recommended filename, but it <I>is</I>
judged to be &quot;evil&quot;, then a warning is issued and we pretend that
there was no recommended filename.  In which case...


<P><LI>If the MIME header does not specify a recommended filename, then
a simple temporary file name, starting with the <CODE>output_prefix()</CODE>, 
will be used.

</UL>


<P>
<B>Note:</B> If you don't like the behavior of this function, you 
can define your own subclass of MIME::Parser and override it there:


<P>
<PRE>     package MIME::MyParser;</PRE>



<P>
<PRE>     require 5.002;                # for SUPER
     use package MIME::Parser;</PRE>



<P>
<PRE>     @MIME::MyParser::ISA = ('MIME::Parser');</PRE>



<P>
<PRE>     sub output_path {
         my (&#36;self, &#36;head) = @_;</PRE>



<P>
<PRE>         # Your code here; FOR EXAMPLE...
         if (i_have_a_preference) {
	     return my_custom_path;
         }
	 else {                      # return the default path:
             return &#36;self-&gt;SUPER::output_path(&#36;head);
         }
     }
     1;</PRE>



<P>
<B>Note:</B> Nickolay Saukh pointed out that, given the subjective nature of
what is &quot;evil&quot;, this function really shouldn't <I>warn</I> about an evil
filename, but maybe just issue a <I>debug</I> message.  I considered that, 
but then I thought: if debugging were off, people wouldn't know why 
(or even if) a given filename had been ignored.  In mail robots
that depend on externally-provided filenames, this could cause 
hard-to-diagnose problems.  So, the message is still a warning, but 
now <B>it's only output if &#36;^W is true.</B>


<P>
<I>Thanks to Laurent Amon for pointing out problems with the original
implementation, and for making some good suggestions.  Thanks also to
Achim Bohnet for pointing out that there should be a hookless, OO way of 
overriding the output_path.</I>


<P><DT><B><A NAME="output_prefix">output_prefix [PREFIX]</A></B><DD>

<I>Instance method.</I>
Get/set the output prefix for the parsing operation.
This is a short string that all filenames for extracted and decoded 
body parts will begin with.  The default is <I>&quot;msg&quot;</I>.


<P>
If <CODE>PREFIX</CODE> <I>is not</I> given, the current output prefix is returned.
If <CODE>PREFIX</CODE> <I>is</I> given, the output directory is set to the new value,
and the previous value is returned.


<P><DT><B><A NAME="output_to_core">output_to_core [CUTOFF]</A></B><DD>

<I>Instance method.</I>
Normally, instances of this class output all their decoded body
data to disk files (via MIME::Body::File).  However, you can change 
this behaviour by invoking this method before parsing:


<P>
<B>If CUTOFF is an integer,</B> then we examine the <CODE>Content-length</CODE> of 
each entity being parsed.  If the content-length is known to be
CUTOFF or below, the body data will go to an in-core data structure;
If the content-length is unknown or if it exceeds CUTOFF, then
the body data will go to a disk file.


<P>
<B>If the CUTOFF is the string &quot;NONE&quot;,</B> then all body data goes to disk 
files regardless of the content-length.  This is the default behaviour.


<P>
<B>If the CUTOFF is the string &quot;ALL&quot;,</B> then all body data goes to 
in-core data structures regardless of the content-length.  
<B>This is very risky</B> (what if someone emails you an MPEG or a tar 
file, hmmm?) but people seem to want this bit of noose-shaped rope,
so I'm providing it.


<P>
Without argument, returns the current cutoff: &quot;ALL&quot;, &quot;NONE&quot; (the default), 
or a number.


<P>
See the <CODE>new_body_for()</CODE> method for more details.

</DL>


<P><HR>
<A NAME="writing_subclasses">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
WRITING SUBCLASSES</FONT></H1>
</A>


<P>
Authors of subclasses can consider overriding the following methods.
They are listed in approximate order of most-to-least impact.

<DL>
<P><DT><B><A NAME="new_body_for">new_body_for</A></B><DD>

Override this if you want to change the <I>entire</I> mechanism for choosing 
the output destination.  You may want to use information in the MIME
header to determine how files are named, and whether or not their data
goes to a disk file or to an in-core scalar.
(You have the MIME header object at your disposal.)


<P><DT><B><A NAME="output_path">output_path</A></B><DD>

Override this if you want to completely change how the output path
(containing both the directory and filename) is determined for those
parts being output to disk files.  
(You have the MIME header object at your disposal.)


<P><DT><B><A NAME="evil_filename">evil_filename</A></B><DD>

Override this if you want to change the test that determines whether
or not a filename obtained from the header is permissible.


<P><DT><B><A NAME="output_prefix">output_prefix</A></B><DD>

Override this if you want to change the mechanism for getting/setting
the desired output prefix (used in naming files when no other names
are suggested).


<P><DT><B><A NAME="output_dir">output_dir</A></B><DD>

Override this if you want to change the mechanism for getting/setting
the desired output directory (where extracted and decoded files are placed).

</DL>


<P><HR>
<A NAME="author">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
AUTHOR</FONT></H1>
</A>


<P>
Copyright (c) 1997 by Eryq / eryq@zeegee.com


<P>
All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.


<P><HR>
<A NAME="version">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
VERSION</FONT></H1>
</A>


<P>
&#36;Revision: 4.102 &#36; &#36;Date: 1997/12/14 03:04:10 &#36;


<P><HR>
<SMALL>
		Last updated: Wed Jan 14 10:21:59 1998 <BR>
		Generated by pod2coolhtml 1.101.  Want a copy?  Just email
		<A HREF="mailto:eryq@enteract.com">eryq@enteract.com</A>.
		(Yes, it's free.)
		</SMALL></BODY>
</HTML>
