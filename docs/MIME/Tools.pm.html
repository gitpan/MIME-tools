<HTML>
<HEAD>
  <TITLE>MIME-tools</TITLE>
</HEAD>
<BODY 
       bgcolor="#FFFFFF" link="#BE1B58" vlink="#8C337C" alink="#F28EAA">
<A HREF="http://www.zeegee.com" TARGET="_top"><IMG SRC="icons/zeegee.gif" ALT="ZeeGee Software" ALIGN="RIGHT" BORDER="0"></A><A NAME="__TOP__"><H1>MIME-tools</H1>
</A>
<P><B>This module is <FONT COLOR="#990000">ALPHA</FONT> code, which means that public interfaces are largely untested, and may change in future releases. Use with caution! Please report any errors back to <A HREF="mailto:eryq@zeegee.com">eryq@zeegee.com</A> as soon as you can.</B><UL>
<LI> <A HREF="#NAME">NAME</A>
<LI> <A HREF="#SYNOPSIS">SYNOPSIS</A>
<LI> <A HREF="#DESCRIPTION">DESCRIPTION</A>
<LI> <A HREF="#A_QUICK_TOUR">A QUICK TOUR</A>
<UL>
<LI> <A HREF="#Overview_of_the_classes">Overview of the classes</A>
<LI> <A HREF="#Parsing_in_a_nutshell">Parsing, in a nutshell</A>
<LI> <A HREF="#Composing_in_a_nutshell">Composing, in a nutshell</A>
<LI> <A HREF="#Encoding_decoding_in_a_nutshell">Encoding/decoding, in a nutshell</A>
<LI> <A HREF="#Other_stuff_you_can_do">Other stuff you can do</A>
<LI> <A HREF="#Good_advice">Good advice</A>
</UL>
<LI> <A HREF="#NOTES">NOTES</A>
<UL>
<LI> <A HREF="#Design_issues">Design issues</A>
<LI> <A HREF="#Questionable_practices">Questionable practices</A>
</UL>
<LI> <A HREF="#A_MIME_PRIMER">A MIME PRIMER</A>
<UL>
<LI> <A HREF="#Glossary">Glossary</A>
<LI> <A HREF="#Content_types">Content types</A>
<LI> <A HREF="#Content_transfer_encodings">Content transfer encodings</A>
</UL>
<LI> <A HREF="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</A>
<LI> <A HREF="#SUPPORT">SUPPORT</A>
<LI> <A HREF="#CHANGE_LOG">CHANGE LOG</A>
<LI> <A HREF="#AUTHOR">AUTHOR</A>
<LI> <A HREF="#VERSION">VERSION</A>
<LI> <A HREF="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</A>
<LI> <A HREF="#SEE_ALSO">SEE ALSO</A>
</UL>
</A>

<P><HR>
<A NAME="NAME"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NAME</H2></A>


<P>MIME-tools - modules for parsing (and creating!) MIME entities



<P><HR>
<A NAME="SYNOPSIS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> SYNOPSIS</H2></A>


<P>Here's some pretty basic code for <B>parsing a MIME message,</B> and outputting
its decoded components to a given directory:

<PRE>
    use MIME::Parser;
     
    ### Create parser, and set some parsing options:
    my $parser = new MIME::Parser;
    $parser-&gt;output_under(&quot;$ENV{HOME}/mimemail&quot;);
     
    ### Parse input:
    $entity = $parser-&gt;parse(\*STDIN) or die &quot;parse failed\n&quot;;
    
    ### Take a look at the top-level entity (and any parts it has):
    $entity-&gt;dump_skeleton; 
</PRE>

<P>Here's some code which <B>composes and sends a MIME message</B> containing 
three parts: a text file, an attached GIF, and some more text:

<PRE>
    use MIME::Entity;
</PRE>
<PRE>
    ### Create the top-level, and set up the mail headers:
    $top = MIME::Entity-&gt;build(Type    =&gt;&quot;multipart/mixed&quot;,
                               From    =&gt; &quot;me\@myhost.com&quot;,
	                       To      =&gt; &quot;you\@yourhost.com&quot;,
                               Subject =&gt; &quot;Hello, nurse!&quot;);
    
    ### Part #1: a simple text document: 
    $top-&gt;attach(Path=&gt;&quot;./testin/short.txt&quot;);
    
    ### Part #2: a GIF file:
    $top-&gt;attach(Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                 Type        =&gt; &quot;image/gif&quot;,
                 Encoding    =&gt; &quot;base64&quot;);
        
    ### Part #3: some literal text:
    $top-&gt;attach(Data=&gt;$message);
    
    ### Send it:
    open MAIL, &quot;| /usr/lib/sendmail -t -oi -oem&quot; or die &quot;open: $!&quot;;
    $top-&gt;print(\*MAIL);
    close MAIL;
</PRE>


<P><HR>
<A NAME="DESCRIPTION"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> DESCRIPTION</H2></A>


<P>MIME-tools is a collection of Perl5 MIME:: modules for parsing, decoding,
<I>and generating</I> single- or multipart (even nested multipart) MIME 
messages.  (Yes, kids, that means you can send messages with attached 
GIF files).



<P><HR>
<A NAME="A_QUICK_TOUR"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> A QUICK TOUR</H2></A>



<P><HR>
<A NAME="Overview_of_the_classes"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Overview of the classes</H3></A>


<P>Here are the classes you'll generally be dealing with directly:

<PRE>
           .------------.
           | MIME::     |
           | Parser     |
           `------------'
              | parse()
              | returns a...
              |
              |
              |
              |    head()       .--------.
              |    returns...   | MIME:: | get()
              V       .--------&gt;| Head   | etc... 
           .--------./          `--------'      
     .---&gt; | MIME:: | 
     `-----| Entity |           .--------. 
   parts() `--------'\          | MIME:: | 
   returns            `--------&gt;| Body   |
   sub-entities    bodyhandle() `--------'
   (if any)        returns...       | open() 
                                    | returns...
                                    | 
                                    V  
                                .--------. read()    
                                | IO::   | getline()  
                                | Handle | print()          
                                `--------' etc...    
</PRE>

<P>To illustrate, parsing works this way:



<UL>
<P><LI>
<P><B>The &quot;parser&quot; parses the MIME stream.</B>
A parser is an instance of <CODE>MIME::Parser</CODE>.  
You hand it an input stream (like a filehandle) to parse a message from: 
if the parse is successful, the result is an &quot;entity&quot;.

<P><LI>
<P><B>A parsed message is represented by an &quot;entity&quot;.</B>
An entity is an instance of <CODE>MIME::Entity</CODE> (a subclass of <CODE>Mail::Internet</CODE>).
If the message had &quot;parts&quot; (e.g., attachments), then those parts
are &quot;entities&quot; as well, contained inside the top-level entity.
Each entity has a &quot;head&quot; and a &quot;body&quot;.

<P><LI>
<P><B>The entity's &quot;head&quot; contains information about the message.</B>  
A &quot;head&quot; is an instance of <CODE>MIME::Head</CODE> (a subclass of <CODE>Mail::Header</CODE>).
It contains information from the message header: content type,
sender, subject line, etc.

<P><LI>
<P><B>The entity's &quot;body&quot; knows where the message data is.</B>  
You can ask to &quot;open&quot; this data source for <I>reading</I> or <I>writing</I>, 
and you will get back an &quot;I/O handle&quot;.

<P><LI>
<P><B>You can open() a &quot;body&quot; and get an &quot;I/O handle&quot; to read/write message data.</B>
This handle is an object that is basically like an IO::Handle or 
a FileHandle... it can be any class, so long as it supports a small,
standard set of methods for reading from or writing to the underlying
data source.

</UL>


<P>A typical multipart message containing two parts -- a textual greeting 
and an &quot;attached&quot; GIF file -- would be a tree of MIME::Entity objects,
each of which would have its own MIME::Head.  Like this:

<PRE>
    .--------.
    | MIME:: | Content-type: multipart/mixed 
    | Entity | Subject: Happy Samhaine!
    `--------'
         |
         `----.
        parts |
              |   .--------.   
              |---| MIME:: | Content-type: text/plain; charset=us-ascii
              |   | Entity | Content-transfer-encoding: 7bit
              |   `--------' 
              |   .--------.   
              |---| MIME:: | Content-type: image/gif
                  | Entity | Content-transfer-encoding: base64
                  `--------' Content-disposition: inline; 
                               filename=&quot;hs.gif&quot;
</PRE>


<P><HR>
<A NAME="Parsing_in_a_nutshell"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Parsing, in a nutshell</H3></A>


<P>You usually start by creating an instance of <B>MIME::Parser</B>
and setting up certain parsing parameters: what directory to save 
extracted files to, how to name the files, etc.


<P>You then give that instance a readable filehandle on which waits a
MIME message.  If all goes well, you will get back a <B>MIME::Entity</B>
object (a subclass of <B>Mail::Internet</B>), which consists of...



<UL>
<P><LI>
<P>A <B>MIME::Head</B> (a subclass of <B>Mail::Header</B>) which holds the MIME 
header data.

<P><LI>
<P>A <B>MIME::Body</B>, which is a object that knows where the body data is.
You ask this object to &quot;open&quot; itself for reading, and it
will hand you back an &quot;I/O handle&quot; for reading the data: this is
a FileHandle-like object, and could be of any class, so long as it
conforms to a subset of the <B>IO::Handle</B> interface.  

</UL>


<P>If the original message was a multipart document, the MIME::Entity
object will have a non-empty list of &quot;parts&quot;, each of which is in 
turn a MIME::Entity (which might also be a multipart entity, etc, 
etc...).


<P>Internally, the parser (in MIME::Parser) asks for instances 
of <B>MIME::Decoder</B> whenever it needs to decode an encoded file.  
MIME::Decoder has a mapping from supported encodings (e.g., 'base64') 
to classes whose instances can decode them.  You can add to this mapping 
to try out new/experiment encodings.  You can also use 
MIME::Decoder by itself.  



<P><HR>
<A NAME="Composing_in_a_nutshell"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Composing, in a nutshell</H3></A>


<P>All message composition is done via the <B>MIME::Entity</B> class.
For single-part messages, you can use the <B>MIME::Entity/build</B>
constructor to create MIME entities very easily.


<P>For multipart messages, you can start by creating a top-level
<CODE>multipart</CODE> entity with <B>MIME::Entity::build()</B>, and then use
the similar <B>MIME::Entity::attach()</B> method to attach parts to 
that message.  <I>Please note:</I> what most people think of as 
&quot;a text message with an attached GIF file&quot; is <I>really</I> a multipart
message with 2 parts: the first being the text message, and the
second being the GIF file. 


<P>When building MIME a entity, you'll have to provide two very important
pieces of information: the <I>content type</I> and the 
<I>content transfer encoding</I>.  The type is usually easy, as it is directly 
determined by the file format; e.g., an HTML file is <CODE>text/html</CODE>.   
The encoding, however, is trickier... for example, some HTML files are
<CODE>7bit</CODE>-compliant, but others might have very long lines and would need to be
sent <CODE>quoted-printable</CODE> for reliability.  


<P>See the section on encoding/decoding for more details, as well as
<A HREF="#A_MIME_PRIMER">A MIME PRIMER</A>.



<P><HR>
<A NAME="Encoding_decoding_in_a_nutshell"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Encoding/decoding, in a nutshell</H3></A>


<P>The <B>MIME::Decoder</B> class can be used to <I>encode</I> as well; this is done
when printing MIME entities.  All the standard encodings are supported
(see <A HREF="#A_MIME_PRIMER">A MIME PRIMER</A> for details): 

<PRE>
    Encoding...       Normally used when message contents are...
    -------------------------------------------------------------------
    7bit              7-bit data with under 1000 chars/line, or multipart.
    8bit              8-bit data with under 1000 chars/line.
    binary            8-bit data with possibly long lines (or no line breaks).
    quoted-printable  Text files with some 8-bit chars (e.g., Latin-1 text).
    base64            Binary files.
</PRE>

<P>Which encoding you choose for a given document depends largely on 
(1) what you know about the document's contents (text vs binary), and
(2) whether you need the resulting message to have a reliable encoding
for 7-bit Internet email transport. 


<P>In general, only <CODE>quoted-printable</CODE> and <CODE>base64</CODE> guarantee reliable
transport of all data; the other three &quot;no-encoding&quot; encodings simply
pass the data through, and are only reliable if that data is 7bit ASCII 
with under 1000 characters per line, and has no conflicts with the
multipart boundaries.


<P>I've considered making it so that the content-type and encoding
can be automatically inferred from the file's path, but that seems
to be asking for trouble... or at least, for Mail::Cap...



<P><HR>
<A NAME="Other_stuff_you_can_do"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Other stuff you can do</H3></A>


<P>If you want to tweak the way this toolkit works (for example, to 
turn on debugging), use the routines in the <B>MIME::ToolUtils</B> module.



<P><HR>
<A NAME="Good_advice"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Good advice</H3></A>



<UL>
<P><LI>
<P><B>Run with -w on.</B>  If you see a warning about a deprecated method,
change your code ASAP.  This will ease upgrades tremendously.

<P><LI>
<P><B>Don't try to MIME-encode using the non-standard MIME encodings.</B>
It's just not a good practice if you want people to be able to
read your messages.

<P><LI>
<P><B>Be aware of possible thrown exceptions.</B>
For example, if your mail-handling code absolutely must not die, 
then perform mail parsing like this:

<PRE>
    $entity = eval { $parser-&gt;parse(\*INPUT) };
</PRE>

<P>Parsing is a complex process, and some components may throw exceptions
if seriously-bad things happen.  Since &quot;seriously-bad&quot; is in the
eye of the beholder, you're better off <I>catching</I> possible exceptions 
instead of asking me to propagate <CODE>undef</CODE> up the stack.  Use of exceptions in
reusable modules is one of those religious issues we're never all 
going to agree upon; thankfully, that's what <CODE>eval{}</CODE> is good for.

</UL>



<P><HR>
<A NAME="NOTES"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NOTES</H2></A>



<P><HR>
<A NAME="Design_issues"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Design issues</H3></A>



<DL>
<P><DT><B><A NAME="item:Why_the_need_for_temp_files_Why_not_do_everything_in_core">Why the need for temp files?  Why not do everything in core?</A></B></DT>
<DD>
Although the amount of core available on even a modest home
system continues to grow, the size of attachments continues
to grow with it.  I wanted to make sure that even users with small
systems could deal with decoding multi-megabyte sounds and movie files.
That means not being core-bound.

<P><DT><B><A NAME="item:Why_assume_that_MIME_objects_are_email_objects">Why assume that MIME objects are email objects?</A></B></DT>
<DD>
Achim Bohnet once pointed out that MIME headers do nothing more than
store a collection of attributes, and thus could be represented as
objects which don't inherit from Mail::Header.


<P>I agree in principle, but RFC-1521 says otherwise.
RFC-1521 [MIME] headers are a syntactic subset of RFC-822 [email] headers.
Perhaps a better name for these modules would have been RFC1521:: 
instead of MIME::, but we're a little beyond that stage now.


<P>When I originally wrote these modules for the CPAN, I agonized for a long
time about whether or not they really should subclass from <B>Mail::Internet</B> 
(then at version 1.17).  Thanks to Graham Barr, who graciously evolved
MailTools 1.06 to be more MIME-friendly, unification was achieved
at MIME-tools release 2.0.   
The benefits in reuse alone have been substantial.

</DL>



<P><HR>
<A NAME="Questionable_practices"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Questionable practices</H3></A>



<DL>
<P><DT><B><A NAME="item:Fuzzing_of_CRLF_and_newline_on_input">Fuzzing of CRLF and newline on input</A></B></DT>
<DD>
RFC-1521 dictates that MIME streams have lines terminated by CRLF
(<CODE>&quot;\r\n&quot;</CODE>).  However, it is extremely likely that folks will want to 
parse MIME streams where each line ends in the local newline 
character <CODE>&quot;\n&quot;</CODE> instead. 


<P>An attempt has been made to allow the parser to handle both CRLF 
and newline-terminated input.  

<P><DT><B><A NAME="item:Fuzzing_of_CRLF_and_newline_when_decoding">Fuzzing of CRLF and newline when decoding</A></B></DT>
<DD>
The <CODE>&quot;7bit&quot;</CODE> and <CODE>&quot;8bit&quot;</CODE> decoders will decode both
a <CODE>&quot;\n&quot;</CODE> and a <CODE>&quot;\r\n&quot;</CODE> end-of-line sequence into a <CODE>&quot;\n&quot;</CODE>.


<P>The <CODE>&quot;binary&quot;</CODE> decoder (default if no encoding specified) 
still outputs stuff verbatim... so a MIME message with CRLFs 
and no explicit encoding will be output as a text file 
that, on many systems, will have an annoying ^M at the end of
each line... <I>but this is as it should be</I>.

<P><DT><B><A NAME="item:Fuzzing_of_CRLF_and_newline_when_encoding_composing">Fuzzing of CRLF and newline when encoding/composing</A></B></DT>
<DD>
All encoders currently output the end-of-line sequence as a <CODE>&quot;\n&quot;</CODE>,
with the assumption that the local mail agent will perform
the conversion from newline to CRLF when sending the mail.
However, there probably should be an option to output CRLF as per RFC-1521.

<P><DT><B><A NAME="item:Inability_to_handle_multipart_boundaries_with_embedded_newlines">Inability to handle multipart boundaries with embedded newlines</A></B></DT>
<DD>
First, let's get something straight: this is an evil, EVIL practice.
If your mailer creates multipart boundary strings that contain 
newlines, give it two weeks notice and find another one.  If your
mail robot receives MIME mail like this, regard it as syntactically
incorrect, which it is.

</DL>



<P><HR>
<A NAME="A_MIME_PRIMER"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> A MIME PRIMER</H2></A>


<P>So you need to parse (or create) MIME, but you're not quite up on 
the specifics?  No problem...



<P><HR>
<A NAME="Glossary"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Glossary</H3></A>


<P>Here are some definitions adapted from RFC-1521 explaining the terminology
we use; each is accompanied by the equivalent in MIME:: module terms...



<DL>
<P><DT><B><A NAME="item:attachment">attachment</A></B></DT>
<DD>
An &quot;attachment&quot; is common slang for any part of a multipart message --
except, perhaps, for the first part, which normally carries a user
message describing the attachments that follow (e.g.: &quot;Hey dude, here's
that GIF file I promised you.&quot;).


<P>In our system, an attachment is just a <B>MIME::Entity</B> under the
top-level entity, probably one of its <A HREF="../MIME/Entity.pm.html#item:parts">parts</A>.

<P><DT><B><A NAME="item:body">body</A></B></DT>
<DD>
The &quot;body&quot; of an <A HREF="#item:entity">entity</A> is that portion of the entity 
which follows the <A HREF="#item:header">header</A> and which contains the real message 
content.  For example, if your MIME message has a GIF file attachment,
then the body of that attachment is the base64-encoded GIF file itself.


<P>A body is represented by an instance of <B>MIME::Body</B>.  You get the
body of an entity by sending it a <A HREF="../MIME/Entity.pm.html#item:bodyhandle">bodyhandle()</A> 
message.

<P><DT><B><A NAME="item:body_part">body part</A></B></DT>
<DD>
One of the parts of the body of a multipart <B>/entity</B>. 
A body part has a <B>/header</B> and a <B>/body</B>, so it makes sense to
speak about the body of a body part.


<P>Since a body part is just a kind of entity, it's represented by 
an instance of <B>MIME::Entity</B>.

<P><DT><B><A NAME="item:entity">entity</A></B></DT>
<DD>
An &quot;entity&quot; means either a <B>/message</B> or a <B>/body part</B>.  
All entities have a <B>/header</B> and a <B>/body</B>.


<P>An entity is represented by an instance of <B>MIME::Entity</B>.
There are instance methods for recovering the 
<A HREF="../MIME/Entity.pm.html#item:head">header</A> (a <B>MIME::Head</B>) and the
<A HREF="../MIME/Entity.pm.html#item:bodyhandle">body</A> (a <B>MIME::Body</B>).

<P><DT><B><A NAME="item:header">header</A></B></DT>
<DD>
This is the top portion of the MIME message, which contains the
&quot;Content-type&quot;, &quot;Content-transfer-encoding&quot;, etc.  Every MIME entity has
a header, represented by an instance of <B>MIME::Head</B>.  You get the
header of an entity by sending it a head() message.

<P><DT><B><A NAME="item:message">message</A></B></DT>
<DD>
A &quot;message&quot; generally means the complete (or &quot;top-level&quot;) message being 
transferred on a network.


<P>There currently is no explicit package for &quot;messages&quot;; under MIME::, 
messages are streams of data which may be read in from files or 
filehandles.  You can think of the <B>MIME::Entity</B> returned by the
<B>MIME::Parser</B> as representing the full message.

</DL>



<P><HR>
<A NAME="Content_types"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Content types</H3></A>


<P>This indicates what kind of data is in the MIME message, usually
as <I>majortype/minortype</I>.  The standard major types are shown below.
A more-comprehensive listing may be found in RFC-2046.



<DL>
<P><DT><B><A NAME="item:application">application</A></B></DT>
<DD>
Data which does not fit in any of the other categories, particularly 
data to be processed by some type of application program. 
<CODE>application/octet-stream</CODE>, <CODE>application/gzip</CODE>, <CODE>application/postscript</CODE>...

<P><DT><B><A NAME="item:audio">audio</A></B></DT>
<DD>
Audio data.
<CODE>audio/basic</CODE>...

<P><DT><B><A NAME="item:image">image</A></B></DT>
<DD>
Graphics data.
<CODE>image/gif</CODE>, <CODE>image/jpeg</CODE>...

<P><DT><B><A NAME="item:message">message</A></B></DT>
<DD>
A message, usually another mail or MIME message.
<CODE>message/rfc822</CODE>...

<P><DT><B><A NAME="item:multipart">multipart</A></B></DT>
<DD>
A message containing other messages.
<CODE>multipart/mixed</CODE>, <CODE>multipart/alternative</CODE>...

<P><DT><B><A NAME="item:text">text</A></B></DT>
<DD>
Textual data, meant for humans to read.
<CODE>text/plain</CODE>, <CODE>text/html</CODE>...

<P><DT><B><A NAME="item:video">video</A></B></DT>
<DD>
Video or video+audio data.
<CODE>video/mpeg</CODE>...

</DL>



<P><HR>
<A NAME="Content_transfer_encodings"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Content transfer encodings</H3></A>


<P>This is how the message body is packaged up for safe transit.
There are the 5 major MIME encodings.
A more-comprehensive listing may be found in RFC-2045.



<DL>
<P><DT><B><A NAME="item:7bit">7bit</A></B></DT>
<DD>
No encoding is done at all.  This label simply asserts that no
8-bit characters are present, and that lines do not exceed 1000 characters 
in length (including the CRLF).

<P><DT><B><A NAME="item:8bit">8bit</A></B></DT>
<DD>
No encoding is done at all.  This label simply asserts that the message 
might contain 8-bit characters, and that lines do not exceed 1000 characters 
in length (including the CRLF).

<P><DT><B><A NAME="item:binary">binary</A></B></DT>
<DD>
No encoding is done at all.  This label simply asserts that the message 
might contain 8-bit characters, and that lines may exceed 1000 characters 
in length.  Such messages are the <I>least</I> likely to get through mail 
gateways.

<P><DT><B><A NAME="item:base64">base64</A></B></DT>
<DD>
A standard encoding, which maps arbitrary binary data to the 7bit domain.
Like &quot;uuencode&quot;, but very well-defined.  This is how you should send
essentially binary information (tar files, GIFs, JPEGs, etc.). 

<P><DT><B><A NAME="item:quoted-printable">quoted-printable</A></B></DT>
<DD>
A standard encoding, which maps arbitrary line-oriented data to the
7bit domain.  Useful for encoding messages which are textual in
nature, yet which contain non-ASCII characters (e.g., Latin-1,
Latin-2, or any other 8-bit alphabet).

</DL>



<P><HR>
<A NAME="TERMS_AND_CONDITIONS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> TERMS AND CONDITIONS</H2></A>


<P>Eryq (<I><FILE><A HREF="mailto:eryq@zeegee.com">eryq@zeegee.com</A></FILE></I>), ZeeGee Software Inc (<I><FILE><A HREF="http://www.zeegee.com">http://www.zeegee.com</A></FILE></I>).


<P>Copyright (c) 1998, 1999 by ZeeGee Software Inc (www.zeegee.com).


<P>All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.  
See the COPYING file in the distribution for details.



<P><HR>
<A NAME="SUPPORT"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> SUPPORT</H2></A>


<P>Please email me directly with questions/problems (see AUTHOR below).


<P>If you want to be placed on an email distribution list (not a mailing list!)
for MIME-tools, and receive bug reports, patches, and updates as to when new 
MIME-tools releases are planned, just email me and say so.  If your project
is using MIME-tools, it might not be a bad idea to find out about those
bugs <I>before</I> they become problems...



<P><HR>
<A NAME="CHANGE_LOG"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> CHANGE LOG</H2></A>



<DL>
<P><DT><B><A NAME="item:Version">Version 5.207</A></B></DT>
<DD>
Fixed bug in MIME::Parser where the &quot;warning&quot; method whine() was 
called as a static function instead of invoked as an instance method.  
<I>Thanks to Todd A. Bradfute for reporting this.</I>

<PRE>
       A simple warning
          Invokes method as function:
       &quot;Warning&quot; makes us die
</PRE>
<P><DT><B><A NAME="item:Version">Version 5.206</A></B></DT>
<DD>
Ahem.  Cough cough:

<PRE>
       Way too many bugs
          Thus, a self-imposed penance:
       Write haiku for each
</PRE>

<P>Fixed bug in MIME::Parser: the reader was not handling the 
odd (but legal) case where a multipart boundary is followed by linear 
whitespace.
<I>Thanks to Jon Agnew for reporting this with the RFC citation.</I>

<PRE>
       Legal message fails
          And 'round the globe, thousands cry:
       READ THE RFC
</PRE>

<P>Empty preambles are now handled properly by MIME::Entity when
printing: there is now no space between the header-terminator
and the initial boundary.
<I>Thanks to &quot;sen_ml&quot; for suggesting this.</I>

<PRE>
       Nature hates vacuum
          But please refrain from tossing
       Newlines in the void
</PRE>

<P>Started using Benchmark for benchmarking.

<P><DT><B><A NAME="item:Version">Version 5.205</A></B></DT>
<DD>
Added terminating newline to all parser messages, and fixed
small parser bug that was dropping parts when errors occurred
in certain places.

<P><DT><B><A NAME="item:Version">Version 5.203</A></B></DT>
<DD>
Brand new parser based on new (private) MIME::Parser::Reader and 
(public) MIME::Parser::Results.  Fast and yet simple and very tolerant
of bad MIME when desired.  Message reporting needs some muzzling.


<P>MIME::Parser now has ignore_errors() set true by default.

<P><DT><B><A NAME="item:Version">Version 5.116</A></B></DT>
<DD>
Removed Tmpfile.t test, which was causing a bogus failure in 
&quot;make test&quot;.  Now we require 5.004 for MIME::Parser anyway,
so we don't need it.  <I>Thanks to Jonathan Cohn for reporting this.</I>

<P><DT><B><A NAME="item:Version">Version 5.115</A></B></DT>
<DD>
Fixed Ref.t bug, and documented how to remove parts from a MIME::Entity.

<P><DT><B><A NAME="item:Version">Version 5.114</A></B></DT>
<DD>
Entity now uses MIME::Lite-style default suggested encoding.


<P>More regression test have been added, and the &quot;Size&quot; tests in 
Ref.t are skipped for text document (due to CRLF differences
between platforms).

<P><DT><B><A NAME="item:Version">Version 5.113 (Initial 5.x Beta release)</A></B></DT>
<DD>
<B>Major speed and structural improvements to the parser.</B>
    <I>Major, MAJOR thanks to Noel Burton-Krahn, Jeremy Gilbert,
      and Doru Petrescu for all the patches, benchmarking,
      and Beta-testing!</I>


<P><B>Convenient new one-directory-per-message parsing mechanism.</B>
    Now through <CODE>MIME::Parser</CODE> method <CODE>output_under()</CODE>, 
    you can tell the parser that you want it to create 
    a unique directory for each message parsed, to hold the 
    resulting parts.


<P><B>Elimination of $', $` and $&amp;.</B>
    Wow... I still can't believe I missed this.  D'OH!
    <I>Thanks to Noel Burton-Krahn for all his patches.</I>


<P><B>Parser is more tolerant of weird EOL termination.</B>
    Some mailagents are can terminate lines with &quot;\r\r\n&quot;.
    We're okay with that now when we extract the header.
    <I>Thanks to Joao Fonseca for pointing this out.</I>


<P><B>Parser is tolerant of &quot;From &quot; lines in headers.</B>
    <I>Thanks to Joachim Wieland, Anthony Hinsinger, Marius Stan,
      and numerous others.</I>


<P><B>Parser catches syntax errors in headers.</B>
    <I>Thanks to Russell P. Sutherland for catching this.</I>


<P><B>Parser no longer warns when subtype is undefined.</B>    
    <I>Thanks to Eric-Olivier Le Bigot for his fix.</I>


<P><B>Better integration with Mail::Internet.</B>
    For example, smtpsend() should work fine.
    <I>Thanks to Michael Fischer and others for the patch.</I>


<P><B>Miscellaneous cleanup.</B>
    <I>Thanks to Marcus Brinkmann for additional helpful input.</I>
    <I>Thanks to Klaus Seidenfaden for good feedback on 5.x Alpha!</I>

<P><DT><B><A NAME="item:Version">Version 4.123</A></B></DT>
<DD>
Cleaned up some of the tests for non-Unix OS'es.
Will require a few iterations, no doubt.

<P><DT><B><A NAME="item:Version">Version 4.122</A></B></DT>
<DD>
<B>Resolved CORE::open warnings for 5.005.</B>
        <I>Thanks to several folks for this bug report.</I>

<P><DT><B><A NAME="item:Version">Version 4.121</A></B></DT>
<DD>
<B>Fixed MIME::Words infinite recursion.</B>
        <I>Thanks to several folks for this bug report.</I>

<P><DT><B><A NAME="item:Version">Version 4.117</A></B></DT>
<DD>
<B>Nicer MIME::Entity::build.</B> 
        No longer outputs warnings with undefined Filename, and now
        accepts Charset as well.
	<I>Thanks to Jason Tibbits III for the inspirational patch.</I>


<P><B>Documentation fixes.</B>  
        Hopefully we've seen the last of the pod2man warnings...


<P><B>Better test logging.</B>  
        Now uses ExtUtils::TBone.

<P><DT><B><A NAME="item:Version">Version 4.116</A></B></DT>
<DD>
<B>Bug fix:</B> 
        MIME::Head and MIME::Entity were not downcasing the
        content-type as they claimed.  This has now been fixed.
	<I>Thanks to Rodrigo de Almeida Siqueira for finding this.</I>

<P><DT><B><A NAME="item:Version">Version 4.114</A></B></DT>
<DD>
<B>Gzip64-encoding has been improved, and turned off as a default,</B>
	since it depends on having gzip installed.  
        See MIME::Decoder::Gzip64 if you want to activate it in your app.
	You can	now set up the gzip/gunzip commands to use, as well.
	<I>Thanks to Paul J. Schinder for finding this bug.</I>

<P><DT><B><A NAME="item:Version">Version 4.113</A></B></DT>
<DD>
<B>Bug fix:</B>
        MIME::ParserBase was accidentally folding newlines in header fields.
	<I>Thanks to Jason L. Tibbitts III for spotting this.</I>

<P><DT><B><A NAME="item:Version">Version 4.112</A></B></DT>
<DD>
<B>MIME::Entity::print_body now recurses</B> when printing multipart
	entities, and prints &quot;everything following the header.&quot;  This is more
	likely what people expect to happen.  PLEASE read the
        &quot;two body problem&quot; section of MIME::Entity's docs.

<P><DT><B><A NAME="item:Version">Version 4.111</A></B></DT>
<DD>
Clean build/test on Win95 using 5.004.  Whew.

<P><DT><B><A NAME="item:Version">Version 4.110</A></B></DT>
<DD>
<B>Added</B> make_multipart() and make_singlepart() in MIME::Entity.


<P><B>Improved</B> handling/saving of preamble/epilogue.

<P><DT><B><A NAME="item:Version">Version 4.109</A></B></DT>
<DD>


<DL>
<P><DT><B><A NAME="item:Overall">Overall</A></B></DT>
<DD>
<B>Major version shift to 4.x</B> 
	accompanies numerous structural changes, and
	the deletion of some long-deprecated code.  Many apologies to those
	who are inconvenienced by the upgrade.


<P><B>MIME::IO deprecated.</B> 
	You'll see IO::Scalar, IO::ScalarArray, and IO::Wrap
	to make this toolkit work.


<P><B>MIME::Entity deep code.</B>
	You can now deep-copy MIME entities (except for on-disk data files).

<P><DT><B><A NAME="item:Encoding_decoding">Encoding/decoding</A></B></DT>
<DD>
<B>MIME::Latin1 deprecated, and 8-to-7 mapping removed.</B> 
	Really, MIME::Latin1 was one of my more dumber ideas.  
	It's still there, but if you want to map 8-bit characters to 
	Latin1 ASCII approximations when 7bit encoding, you'll have to 
	request it explicitly.	<I>But use quoted-printable for your 8-bit 
	documents; that's what it's there for!</I>


<P><B>7bit and 8bit &quot;encoders&quot; no longer encode.</B>
	As per RFC-2045, these just do a pass-through of the data,
	but they'll warn you if you send bad data through.


<P><B>MIME::Entity suggests encoding.</B>
	Now you can ask MIME::Entity's build() method to &quot;suggest&quot;
	a legal encoding based on the body and the content-type.
	No more guesswork!  See the &quot;mimesend&quot; example.


<P><B>New module structure for MIME::Decoder classes.</B> 
	It should be easier for you to see what's happening.


<P><B>New MIME decoders!</B>  
	Support added for decoding <CODE>x-uuencode</CODE>, and for 
	decoding/encoding <CODE>x-gzip64</CODE>.  You'll need &quot;gzip&quot; to make
	the latter work.


<P><B>Quoted-printable back on track... and then some.</B>
	The 'quoted-printable' decoder now uses the newest MIME::QuotedPrint,
	and amends its output with guideline #8 from RFC2049 (From/.).
	<I>Thanks to Denis N. Antonioli for suggesting this.</I>

<P><DT><B><A NAME="item:Parsing">Parsing</A></B></DT>
<DD>
<B>Preamble and epilogue are now saved.</B>
	These are saved in the parsed entities as simple
	string-arrays, and are output by print() if there. 
	<I>Thanks to Jason L. Tibbitts for suggesting this.</I>


<P><B>The &quot;multipart/digest&quot; semantics are now preserved.</B> 
	Parts of digest messages have their mime_type() defaulted 
	to &quot;message/rfc822&quot; instead of &quot;text/plain&quot;, as per the RFC.
	<I>Thanks to Carsten Heyl for suggesting this.</I>

<P><DT><B><A NAME="item:Output">Output</A></B></DT>
<DD>
<B>Well-defined, more-complete print() output.</B>
	When printing an entity, the output is now well-defined if the
	entity came from a MIME::Parser, even if using parse_nested_messages.
	See MIME::Entity for details.


<P><B>You can prevent recommended filenames from being output.</B> 
	This possible security hole has been plugged; when building MIME 
	entities, you can specify a body path but suppress the filename
	in the header.
	<I>Thanks to Jason L. Tibbitts for suggesting this.</I>

<P><DT><B><A NAME="item:Bug_fixes">Bug fixes</A></B></DT>
<DD>
<B>Win32 installations should work.</B>
	The binmode() calls should work fine on Win32 now.
	<I>Thanks to numerous folks for their patches.</I>


<P><B>MIME::Head::add()</B> now no longer downcases its argument.
	<I>Thanks to Brandon Browning &amp; Jason L. Tibbitts for finding this bug.</I>

</DL>

<P><DT><B><A NAME="item:Version">Version 3.204</A></B></DT>
<DD>
<B>Bug in MIME::Head::original_text fixed.</B>
	Well, it took a while, but another bug surfaced from my transition 
	from 1.x to 2.x.  This method was, quite idiotically, sorting the 
	header fields.
	<I>Thanks, as usual, to Andreas Koenig for spotting this one.</I>


<P><B>MIME::ParserBase no longer defaults to RFC-1522-decoding headers.</B>
	The documentation correctly stated that the default setting was 
	to <I>not</I> RFC-1522-decode the headers.  The code, on the other hand,
	was init'ing this parser option in the &quot;on&quot; position.  
	This has been fixed.


<P><B>MIME::ParserBase::parse_nested_messages reexamined.</B>
	If you use this feature, please re-read the documentation.
	It explains a little more precisely what the ramifications are.


<P><B>MIME::Entity tries harder to ensure MIME compliance.</B>
	It is now a fatal error to use certain bad combinations of content
	type and encoding when &quot;building&quot;, or to attempt to &quot;attach&quot; to
	anything that is not a multipart document.  My apologies if this
	inconveniences anyone, but it was just too darn easy before for folks
	to create bad MIME, and gosh darn it, good libraries should at least
	<I>try</I> to protect you from mistakes.


<P><B>The &quot;make&quot; now halts if you don't have the right stuff,</B> 
	provided your MakeMaker supports PREREQ_PM.  See <A HREF="#REQUIREMENTS">REQUIREMENTS</A>
	for what you need to install this package.  I still provide
	old courtesy copies of the MIME:: decoding modules.
<I>Thanks to Hugo van der Sanden for suggesting this.</I>


<P><B>The &quot;make test&quot; is far less chatty.</B>
	Okay, okay, STDERR is evil.  Now a <CODE>&quot;make test&quot;</CODE> will just give you
	the important stuff: do a <CODE>&quot;make test TEST_VERBOSE=1&quot;</CODE> if you want
	the gory details (advisable if sending me a bug report).
<I>Thanks to Andreas Koenig for suggesting this.</I>

<P><DT><B><A NAME="item:Version">Version 3.203</A></B></DT>
<DD>
<B>No, there haven't been any major changes between 2.x and 3.x.</B>
	The major-version increase was from a few more tweaks to get $VERSION
	to be calculated better and more efficiently (I had been using RCS
	version numbers in a way which created problems for users of CPAN::).
	After a couple of false starts, all modules have been upgraded to RCS
	3.201 or higher.


<P><B>You can now parse a MIME message from a scalar,</B> 
	an array-of-scalars, or any MIME::IO-compliant object (including IO::
	objects.)  Take a look at parse_data() in MIME::ParserBase.  The
	parser code has been modified to support the MIME::IO interface.
	<I>Thanks to fellow Chicagoan Tim Pierce (and countless others) 
	for asking.</I>


<P><B>More sensible toolkit configuration.</B>
	A new config() method in MIME::ToolUtils makes a lot of toolkit-wide
	configuration cleaner.  Your old calls will still work, but with
	deprecation warnings.


<P><B>You can now sign messages</B> just like in Mail::Internet.
	See MIME::Entity for the interface.


<P><B>You can now remove signatures from messages</B> just like in Mail::Internet.
	See MIME::Entity for the interface.


<P><B>You can now compute/strip content lengths</B> 
	and other non-standard MIME fields.  
	See sync_headers() in MIME::Entity.
	<I>Thanks to Tim Pierce for bringing the basic problem to my attention.</I>


<P><B>Many warnings are now silent unless $^W is true.</B>  
	That means unless you run your Perl with <CODE>-w</CODE>, you won't see 
        deprecation warnings, non-fatal-error messages, etc.  
        But of course you run with <CODE>-w</CODE>, so this doesn't affect you.  <CODE>:-)</CODE>


<P><B>Completed the 7-bit encodings in MIME::Latin1.</B>
	We hadn't had complete coverage in the conversion from 8- to 7-bit; 
	now we do. <I>Thanks to Rolf Nelson for bringing this to my attention.</I>


<P><B>Fixed broken parse_two() in MIME::ParserBase.</B>
	BTW, if your code worked with the &quot;broken&quot; code, it should <I>still</I>
	work.  
	<I>Thanks again to Tim Pierce for bringing this to my attention.</I>

<P><DT><B><A NAME="item:Version">Version 2.14</A></B></DT>
<DD>
Just a few bug fixes to improve compatibility with Mail-Tools 1.08,
and with the upcoming Perl 5.004 release.
<I>Thanks to Jason L. Tibbitts III for reporting the problems so quickly.</I>

<P><DT><B><A NAME="item:Version">Version 2.13</A></B></DT>
<DD>


<DL>
<P><DT><B><A NAME="item:New_features">New features</A></B></DT>
<DD>
<B>Added RFC-1522-style decoding of encoded header fields.</B>
	Header decoding can now be done automatically during parsing via the 
	new <CODE>decode()</CODE> method in MIME::Head... just tell your parser
	object that you want to <CODE>decode_headers()</CODE>. 
	<I>Thanks to Kent Boortz for providing the idea, and the baseline 
	RFC-1522-decoding code!</I>


<P><B>Building MIME messages is even easier.</B>  
	Now, when you use MIME::Entity's <CODE>build()</CODE> or <CODE>attach()</CODE>, 
	you can also supply individual 
	mail headers to set (e.g., <CODE>-Subject</CODE>, <CODE>-From</CODE>, <CODE>-To</CODE>).


<P>Added <CODE>Disposition</CODE> to MIME::Entity's <CODE>build()</CODE> method.
	<I>Thanks to Kurt Freytag for suggesting this feature.</I>


<P>An <CODE>X-Mailer</CODE> header is now output 
	by default in all MIME-Entity-prepared messages, 
	so any bad MIME we generate can be traced back to this toolkit.


<P>Added <CODE>purge()</CODE> method to MIME::Entity for deleteing leftover files.
	<I>Thanks to Jason L. Tibbitts III for suggesting this feature.</I>


<P>Added <CODE>seek()</CODE> and <CODE>tell()</CODE> methods to built-in MIME::IO classes.
	Only guaranteed to work when reading!
	<I>Thanks to Jason L. Tibbitts III for suggesting this feature.</I>


<P>When parsing a multipart message with apparently no boundaries, 
	the error message you get has been improved.  
	<I>Thanks to Andreas Koenig for suggesting this.</I>

<P><DT><B><A NAME="item:Bug_fixes">Bug fixes</A></B></DT>
<DD>
<B>Patched over a Perl 5.002 (and maybe earlier and later) bug involving
FileHandle::new_tmpfile.</B>  It seems that the underlying filehandles
were not being closed when the FileHandle objects went out of scope!
There is now an internal routine that creates true FileHandle
objects for anonymous temp files. 
<I>Thanks to Dragomir R. Radev and Zyx for reporting the weird behavior
that led to the discovery of this bug.</I>


<P>MIME::Entity's <CODE>build()</CODE> method now warns you if you give it an illegal 
boundary string, and substitutes one of its own.


<P>MIME::Entity's <CODE>build()</CODE> method now generates safer, fully-RFC-1521-compliant 
boundary strings.


<P>Bug in MIME::Decoder's <CODE>install()</CODE> method was fixed.  
<I>Thanks to Rolf Nelson and Nickolay Saukh for finding this.</I>


<P>Changed FileHandle::new_tmpfile to FileHandle-&gt;new_tmpfile, so some 
Perl installations will be happier.  
<I>Thanks to Larry W. Virden for finding this bug.</I>


<P>Gave <CODE>=over</CODE> an arg of 4 in all PODs.
<I>Thanks to Larry W. Virden for pointing out the problems of bare =over's</I>

</DL>

<P><DT><B><A NAME="item:Version">Version 2.04</A></B></DT>
<DD>
<B>A bug in MIME::Entity's output method was corrected.</B>
MIME::Entity::print now outputs everything to the desired filehandle
explicitly.  
<I>Thanks to Jake Morrison for pointing out the incompatibility 
with Mail::Header.</I>

<P><DT><B><A NAME="item:Version">Version 2.03</A></B></DT>
<DD>
<B>Fixed bug in autogenerated filenames</B> resulting from transposed &quot;if&quot; 
statement in MIME::Parser, removing spurious printing of header as well.
(Annoyingly, this bug is invisible if debugging is turned on!)
<I>Thanks to Andreas Koenig for bringing this to my attention.</I>


<P>Fixed bug in MIME::Entity::body() where it was using the bodyhandle
completely incorrectly.  
<I>Thanks to Joel Noble for bringing this to my attention.</I>


<P>Fixed MIME::Head::VERSION so CPAN:: is happier.
<I>Thanks to Larry Virden for bringing this to my attention.</I>


<P>Fixed undefined-variable warnings when dumping skeleton
(happened when there was no Subject: line)
<I>Thanks to Joel Noble for bringing this to my attention.</I>

<P><DT><B><A NAME="item:Version">Version 2.02</A></B></DT>
<DD>
<B>Stupid, stupid bugs in both BASE64 encoding and decoding were fixed.</B>
<I>Thanks to Phil Abercrombie for locating them.</I>

<P><DT><B><A NAME="item:Version">Version 2.01</A></B></DT>
<DD>
<B>Modules now inherit from the new Mail:: modules!</B>
This means big changes in behavior.


<P><B>MIME::Parser can now store message data in-core.</B>
There were a <I>lot</I> of requests for this feature.


<P><B>MIME::Entity can now compose messages.</B>
There were a <I>lot</I> of requests for this feature.


<P>Added option to parse <CODE>&quot;message/rfc822&quot;</CODE> as a pseduo-multipart document.
<I>Thanks to Andreas Koenig for suggesting this.</I>

<P><DT><B><A NAME="item:Version">Version 1.13</A></B></DT>
<DD>
MIME::Head now no longer requires space after &quot;:&quot;, although
either a space or a tab after the &quot;:&quot; will be swallowed
if there.  
<I>Thanks to Igor Starovoitov for pointing out this shortcoming.</I>

<P><DT><B><A NAME="item:Version">Version 1.12</A></B></DT>
<DD>
Fixed bugs in parser where CRLF-terminated lines were 
blowing out the handling of preambles/epilogues.
<I>Thanks to Russell Sutherland for reporting this bug.</I>


<P>Fixed idiotic is_multipart() bug.  
<I>Thanks to Andreas Koenig for noticing it.</I>


<P>Added untested binmode() calls to parser for DOS, etc.
systems.  No idea if this will work...


<P>Reorganized the output_path() methods to allow easy use
of inheritance, as per Achim Bohnet's suggestion.


<P>Changed MIME::Head to report mime_type more accurately.


<P>POSIX module no longer loaded by Parser if perl &gt;= 5.002.
Hey, 5.001'ers: let me know if this breaks stuff, okay?


<P>Added unsupported ./examples directory.

<P><DT><B><A NAME="item:Version">Version 1.11</A></B></DT>
<DD>
Converted over to using Makefile.PL.  
<I>Thanks to Andreas Koenig for the much-needed kick in the pants...</I>


<P>Added t/*.t files for testing.  Eeeeeeeeeeeh...it's a start.


<P>Fixed bug in default parsing routine for generating 
output paths; it was warning about evil filenames if
there simply <I>were</I> no recommended filenames.  D'oh!


<P>Fixed redefined parts() method in Entity.


<P>Fixed bugs in Head where field name wasn't being case folded.

<P><DT><B><A NAME="item:Version">Version 1.10</A></B></DT>
<DD>
A typo was causing the epilogue of an inner multipart
message to be swallowed to the end of the OUTER multipart
message; this has now been fixed.  
<I>Thanks to Igor Starovoitov for reporting this bug.</I>


<P>A bad regexp for parameter names was causing 
some parameters to be parsed incorrectly; this has also
been fixed.  
<I>Thanks again to Igor Starovoitov for reporting this bug.</I>
	
It is now possible to get full control of the filenaming
algorithm before output files are generated, and the default
algorithm is safer.  
<I>Thanks to Laurent Amon for pointing out the problems, and suggesting 
some solutions.</I>


<P>Fixed illegal &quot;simple&quot; multipart test file.  D'OH!

<P><DT><B><A NAME="item:Version">Version 1.9</A></B></DT>
<DD>
No changes: 1.8 failed CPAN registration

<P><DT><B><A NAME="item:Version">Version 1.8.</A></B></DT>
<DD>
Fixed incompatibility with 5.001 and FileHandle::new_tmpfile
Added COPYING file, and improved README.

</DL>



<P><HR>
<A NAME="AUTHOR"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> AUTHOR</H2></A>


<P>MIME-tools was created by:

<PRE>
    ___  _ _ _   _  ___ _     
   / _ \| '_| | | |/ _ ' /    Eryq, (eryq@zeegee.com)
  |  __/| | | |_| | |_| |     President, ZeeGee Software Inc.
   \___||_|  \__, |\__, |__   http://www.zeegee.com/
             |___/    |___/   
</PRE>

<P>Released as MIME-parser (1.0): 28 April 1996.
Released as MIME-tools (2.0): Halloween 1996.
Released as MIME-tools (4.0): Christmas 1997. 
Released as MIME-tools (5.0): Mother's Day 2000.



<P><HR>
<A NAME="VERSION"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> VERSION</H2></A>


<P>$Revision: 5.207 $ 



<P><HR>
<A NAME="ACKNOWLEDGMENTS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> ACKNOWLEDGMENTS</H2></A>


<P><B>This kit would not have been possible</B> but for the direct 
contributions of the following:

<PRE>
    Gisle Aas             The MIME encoding/decoding modules.
    Laurent Amon          Bug reports and suggestions.
    Graham Barr           The new MailTools.
    Achim Bohnet          Numerous good suggestions, including the I/O model.
    Kent Boortz           Initial code for RFC-1522-decoding of MIME headers.
    Andreas Koenig        Numerous good ideas, tons of beta testing,
                            and help with CPAN-friendly packaging.
    Igor Starovoitov      Bug reports and suggestions.
    Jason L Tibbitts III  Bug reports, suggestions, patches.
 
Not to mention the Accidental Beta Test Team, whose bug reports (and
comments) have been invaluable in improving the whole:
</PRE>
<PRE>
    Phil Abercrombie
    Mike Blazer
    Brandon Browning
    Kurt Freytag
    Steve Kilbane
    Jake Morrison
    Rolf Nelson
    Joel Noble    
    Michael W. Normandin 
    Tim Pierce
    Andrew Pimlott
    Dragomir R. Radev
    Nickolay Saukh
    Russell Sutherland
    Larry Virden
    Zyx
</PRE>

<P>Please forgive me if I've accidentally left you out.  
Better yet, email me, and I'll put you in.



<P><HR>
<A NAME="SEE_ALSO"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> SEE ALSO</H2></A>


<P>Users of this toolkit may wish to read the documentation of Mail::Header 
and Mail::Internet.


<P>The MIME format is documented in RFCs 1521-1522, and more recently
in RFCs 2045-2049.


<P>The MIME header format is an outgrowth of the mail header format
documented in RFC 822.

<P><HR>
<ADDRESS><FONT SIZE=-1>
Generated Thu Jun  8 23:33:50 2000 by cvu_pod2html
</FONT></ADDRESS>
</BODY>
</HTML>
