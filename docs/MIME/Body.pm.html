<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Generated by pod2coolhtml 1.101
  -- Using Pod::CoolHTML 1.104 , (C) 1997 by Eryq (eryq@zeegee.com).
  --
  -- DO NOT EDIT THIS HTML FILE! All your changes will be lost.
  -- Edit the POD or Perl file that was used to create it.
  -->
<HTML>

<HEAD>
<TITLE>MIME::Body</TITLE>
</HEAD>
<BODY LINK=#C00000 ALINK=#FF2020 VLINK=#900000>
<A NAME="__top"> </A><CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><FONT SIZE=+1>
<A HREF="Tools.pm.html">MIME::Tools</A></FONT></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Body</SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Decoder.pm.html">MIME::Decoder</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Entity.pm.html">MIME::Entity</A></SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Head.pm.html">MIME::Head</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="IO.pm.html">MIME::IO</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Latin1.pm.html">MIME::Latin1</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Parser.pm.html">MIME::Parser</A></SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="ParserBase.pm.html">MIME::ParserBase</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="ToolUtils.pm.html">MIME::ToolUtils</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Tools.pm.html">MIME::Tools</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Words.pm.html">MIME::Words</A></SMALL></B></TD>
</TABLE></CENTER>

<P><TABLE WIDTH="100%">

<TR VALIGN="TOP"><TD ALIGN="LEFT"><CENTER>
<H1><FONT SIZE=7 COLOR=#600020><B>MIME::<BR>Body</B></FONT></H1><IMG SRC="mime-sm.gif" ALT="MIME!"></CENTER>
<TD>
<UL>
<LI><A HREF="#name">NAME</A>
</LI><LI><A HREF="#synopsis">SYNOPSIS</A>
</LI><LI><A HREF="#description">DESCRIPTION</A>
</LI><LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
</LI><LI><A HREF="#subclasses">SUBCLASSES</A>
</LI><UL>
<LI><A HREF="#mimebodyfile">MIME::Body::File</A>
</LI><LI><A HREF="#mimebodyscalar">MIME::Body::Scalar</A>
</LI><LI><A HREF="#defining_your_own_subclasses">Defining your own subclasses</A>
</LI></UL>
<LI><A HREF="#notes">NOTES</A>
</LI><LI><A HREF="#author">AUTHOR</A>
</LI><LI><A HREF="#version">VERSION</A>
</LI></UL>

</TABLE>

<P><HR>
<A NAME="name">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NAME</FONT></H1>
</A>


<P>
MIME::Body - the body of a MIME message


<P><HR>
<A NAME="synopsis">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
SYNOPSIS</FONT></H1>
</A>


<P>
Here's how a typical body object is obtained and used:


<P>
<PRE>   # Get the bodyhandle of a MIME::Entity object:
   $body = $entity-&gt;bodyhandle;</PRE>



<P>
<PRE>   # Where's the data?
   if (defined($body-&gt;path)) {   # data is on disk:
       print &quot;data is stored externally, in &quot;, $body-&gt;path;
   }
   else {                        # data is in core:
       print &quot;data is already in core, and is...\n&quot;, $body-&gt;as_string;
   }</PRE>



<P>
<PRE>   # Get rid of anything on disk:
   $body-&gt;purge;</PRE>



<P>
If you don't want to worry about where the data is actually
kept, you can use the generic access methods:


<P>
<PRE>   # Write data to the body:
   $IO = $body-&gt;open(&quot;w&quot;)      || die &quot;open body: $!&quot;;
   $IO-&gt;print($message);
   $IO-&gt;close                  || die &quot;close I/O handle: $!&quot;;</PRE>



<P>
<PRE>   # Read data from the body (in this case, line by line):
   $IO = $body-&gt;open(&quot;r&quot;)      || die &quot;open body: $!&quot;;
   while (defined($_ = $IO-&gt;getline)) {
       # do stuff
   }
   $IO-&gt;close                  || die &quot;close I/O handle: $!&quot;;</PRE>



<P>
<PRE>   # Dump the ENCODED body data to a filehandle:
   $body-&gt;print(\*STDOUT);</PRE>



<P>
<PRE>   # Slurp all the UNENCODED data in, and put it in a scalar:
   $string = $body-&gt;as_string;</PRE>



<P>
<PRE>   # Slurp all the UNENCODED data in, and put it in an array of lines:
   @lines = $body-&gt;as_lines;</PRE>



<P>
For example, this subclass stores the data in a disk file, which
is only opened when needed:


<P>
<PRE>   $body = new MIME::Body::File &quot;/path/to/file&quot;;</PRE>



<P>
While <I>this</I> subclass stores the data in an in-core scalar:


<P>
<PRE>   $body = new MIME::Body::Scalar \$scalar;</PRE>



<P>
In any case, once a MIME::Body has been created, you ask to open it
for reading or writing, which gets you an &quot;i/o handle&quot;: you then use 
the same mechanisms for reading from or writing to that handle, no matter 
what class it is.


<P><HR>
<A NAME="description">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
DESCRIPTION</FONT></H1>
</A>


<P>
MIME messages can be very long (e.g., tar files, MPEGs, etc.) or very
short (short textual notes, as in ordinary mail).  Long messages
are best stored in files, while short ones are perhaps best stored
in core.


<P>
This class is an attempt to define a common interface for objects
which contain message data, regardless of how the data is
physically stored.  The lifespan of a &quot;body&quot; object
usually looks like this:

<UL>

<P><LI><B>1.</B>
<B>Body object is created by a MIME::Parser during parsing.</B>
  It's at this point that the actual MIME::Body subclass is chosen,
  and new() is invoked.  (For example: if the body data is going to 
  a file, then it is at this point that the class MIME::Body::File,
  and the filename, is chosen).


<P><LI><B>2.</B>
<B>Data is written to the body</B> (usually by the MIME parser) like this:
  The body is opened for writing, via <CODE>open(&quot;w&quot;)</CODE>.  This will trash any 
  previous contents, and return an &quot;I/O handle&quot; opened for writing.  
  Data is written to this I/O handle, via print().
  Then the I/O handle is closed, via close().


<P><LI><B>3.</B>
<B>Data is read from the body</B> (usually by the user application) like this: 
  The body is opened for reading by a user application, via <CODE>open(&quot;r&quot;)</CODE>.
  This will return an &quot;I/O handle&quot; opened for reading.
  Data is read from the I/O handle, via read(), getline(), or getlines().
  Then the I/O handle is closed, via close().


<P><LI><B>4.</B>
<B>Body object is destructed.</B>

</UL>

<P>
You can write your own subclasses, as long as they follow the
interface described below.  Implementers of subclasses should assume
that steps 2 and 3 may be repeated any number of times, and in
different orders (e.g., 1-2-2-3-2-3-3-3-3-3-2-4).


<P>
Users should be aware that unless they know for certain what they
have, they should not assume that the body has an underlying
filehandle.


<P><HR>
<A NAME="public_interface">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
PUBLIC INTERFACE</FONT></H1>
</A>

<DL>
<P><DT><B><A NAME="new">new ARGS...</A></B><DD>

<I>Class method, constructor.</I>
Create a new body.  Any ARGS are sent to init().


<P><DT><B><A NAME="init">init ARGS...</A></B><DD>

<I>Instance method, abstract, initiallizer.</I>
This is called automatically by <CODE>new()</CODE>, with the arguments given
to <CODE>new()</CODE>.  The arguments are optional, and entirely up to the
subclass.  The default method does nothing,


<P><DT><B><A NAME="as_lines">as_lines</A></B><DD>

<I>Instance method.</I>
Return the contents of the body as an array of lines (each terminated
by a newline, with the possible exception of the final one).
Returns empty on failure (NB: indistinguishable from an empty body!).


<P>
Note: the default method gets the data via
repeated getline() calls; your subclass might wish to override this.


<P><DT><B><A NAME="as_string">as_string</A></B><DD>

<I>Instance method.</I>
Return the body data as a string (slurping it into core if necessary).  
Best not to do this unless you're <I>sure</I> that the body is reasonably small!
Returns empty string for an empty body, and undef on failure.


<P>
Note: the default method uses print(), which gets the data via
repeated read() calls; your subclass might wish to override this.


<P><DT><B><A NAME="binmode">binmode [ONOFF]</A></B><DD>

<I>Instance method.</I>
With argument, flags whether or not open() should return an I/O handle
which has binmode() activated.  With no argument, just returns the
current value.


<P><DT><B><A NAME="dup">dup</A></B><DD>

<I>Instance method.</I>
Duplicate the bodyhandle.


<P>
<I>Beware:</I> external data in bodyhandles is <I>not</I> copied to new files!  
Changing the data in one body's data file, or purging that body,
<I>will</I> affect its duplicate.  Bodies with in-core data probably need
not worry.


<P><DT><B><A NAME="open">open READWRITE</A></B><DD>

<I>Instance method, abstract.</I>
This should do whatever is necessary to open the body for either
writing (if READWRITE is &quot;w&quot;) or reading (if mode is &quot;r&quot;).


<P>
This method is expected to return an &quot;I/O handle&quot; object on success,
and undef on error.  An I/O handle can be any object that supports a 
small set of standard methods for reading/writing data.  
See the IO::Handle class for an example.


<P><DT><B><A NAME="path">path [PATH]</A></B><DD>

<I>Instance method.</I>
If you're storing the body data externally (e.g., in a disk file), you'll 
want to give applications the ability to get at that data, for cleanup.  
This method should return the path to the data, or undef if there is none.


<P>
Where appropriate, the path <I>should</I> be a simple string, like a filename.
With argument, sets the PATH, which should be undef if there is none.


<P><DT><B><A NAME="print">print FILEHANDLE</A></B><DD>

<I>Instance method.</I>
Output the body data to the given filehandle, or to the currently-selected 
one if none is given.


<P><DT><B><A NAME="purge">purge</A></B><DD>

<I>Instance method, abstract.</I>
Remove any data which resides external to the program (e.g., in disk files).
Immediately after a purge(), the path() should return undef to indicate
that the external data is no longer available.

</DL>


<P><HR>
<A NAME="subclasses">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
SUBCLASSES</FONT></H1>
</A>


<P>
The following built-in classes are provided:


<P>
<PRE>   Body                Stores body   When open()ed,
   class:              data in:      returns:    
   --------------------------------------------------------
   MIME::Body::File    disk file     IO::Handle   
   MIME::Body::Scalar  scalar        IO::Scalar  </PRE>



<P><HR>
<A NAME="mimebodyfile">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
MIME::Body::File</FONT></H2>
</A>


<P>
A body class that stores the data in a disk file.  
The I/O handle is a wrapped filehandle.  Invoke the constructor as:


<P>
<PRE>    $body = new MIME::Body::File &quot;/path/to/file&quot;;</PRE>



<P>
In this case, the <CODE>path()</CODE> method would return the given path,
so you <I>could</I> say:


<P>
<PRE>    if (defined($body-&gt;path)) {
	open BODY, $body-&gt;path or die &quot;open: $!&quot;;
	while (&lt;BODY&gt;) {
	    # do stuff
        }
	close BODY;
    }</PRE>



<P>
But you're best off not doing this.


<P><HR>
<A NAME="mimebodyscalar">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
MIME::Body::Scalar</FONT></H2>
</A>


<P>
A body class that stores the data in-core, in a simple scalar.
Invoke the constructor as:


<P>
<PRE>    $body = new MIME::Body::Scalar \$scalar;</PRE>



<P>
A single scalar argument sets the body to that value, exactly as though
you'd opened for the body for writing, written the value, 
and closed the body again:


<P>
<PRE>    $body = new MIME::Body::Scalar &quot;Line 1\nLine 2\nLine 3&quot;;</PRE>



<P>
A single array reference sets the body to the result of joining all the
elements of that array together:


<P>
<PRE>    $body = new MIME::Body::Scalar [&quot;Line 1\n&quot;,
                                    &quot;Line 2\n&quot;,
                                    &quot;Line 3&quot;];</PRE>



<P>
Uses <B>IO::Scalar</B> as the I/O handle.


<P><HR>
<A NAME="defining_your_own_subclasses">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Defining your own subclasses</FONT></H2>
</A>


<P>
So you're not happy with files and scalars?
No problem: just define your own MIME::Body subclass, and make a subclass
of MIME::Parser or MIME::ParserBase which returns an instance of your
body class whenever appropriate in the <CODE>new_body_for(head)</CODE> method.


<P>
Your &quot;body&quot; class must inherit from MIME::Body (or some subclass of it),
and it must either provide (or inherit the default for) the following 
methods...


<P>
The default inherited method <I>should suffice</I> for all these:


<P>
<PRE>    new                       
    binmode [ONOFF]           
    path</PRE>



<P>
The default inherited method <I>may suffice</I> for these, but perhaps 
there's a better implementation for your subclass.


<P>
<PRE>    init ARGS...              
    as_lines                  
    as_string                 
    dup                       
    print                     
    purge </PRE>



<P>
The default inherited method <I>will probably not suffice</I> for these:


<P>
<PRE>    open                      </PRE>



<P><HR>
<A NAME="notes">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NOTES</FONT></H1>
</A>


<P>
One reason I didn't just use FileHandle or IO::Handle objects for message
bodies was that I wanted a &quot;body&quot; object to be a form of completely
encapsulated program-persistent storage; that is, I wanted users
to be able to write code like this...


<P>
<PRE>   # Get body handle from this MIME message, and read its data:
   $body = $entity-&gt;bodyhandle;
   $IO = $body-&gt;open(&quot;r&quot;);
   while (defined($_ = $IO-&gt;getline)) {
       print STDOUT $_;
   }
   $IO-&gt;close;</PRE>



<P>
...without requiring that they know anything more about how the
$body object is actually storing its data (disk file, scalar variable,
array variable, or whatever).


<P>
Storing the body of each MIME message in a persistently-open
IO::Handle was a possibility, but it seemed like a bad idea,
considering that a single multipart MIME message could easily suck up
all the available file descriptors on some systems.  This risk increases 
if the user application is processing more than one MIME entity at a time.


<P><HR>
<A NAME="author">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
AUTHOR</FONT></H1>
</A>


<P>
Copyright (c) 1996, 1997 by Eryq / eryq@zeegee.com


<P>
All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.


<P>
Thanks to Achim Bohnet for suggesting that MIME::Parser not be restricted
to the use of FileHandles.


<P><HR>
<A NAME="version">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
VERSION</FONT></H1>
</A>


<P>
$Revision: 4.107 $ $Date: 1998/01/10 07:27:24 $


<P><HR>
<SMALL>
		Last updated: Fri May  1 17:19:52 1998 <BR>
		Generated by pod2coolhtml 1.101.  Want a copy?  Just email
		<A HREF="mailto:eryq@zeegee.com">eryq@zeegee.com</A>.
		(Yes, it's free.)
		</SMALL></BODY>
</HTML>
