<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Generated by pod2coolhtml 1.101
  -- Using Pod::CoolHTML 1.104 , (C) 1997 by Eryq (eryq@enteract.com).
  --
  -- DO NOT EDIT THIS HTML FILE! All your changes will be lost.
  -- Edit the POD or Perl file that was used to create it.
  -->
<HTML>

<HEAD>
<TITLE>MIME::Decoder</TITLE>
</HEAD>
<BODY LINK=#C00000 ALINK=#FF2020 VLINK=#900000>
<A NAME="__top"> </A><CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><FONT SIZE=+1>
<A HREF="Tools.pm.html">MIME::Tools</A></FONT></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Body.pm.html">MIME::Body</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder</SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Entity.pm.html">MIME::Entity</A></SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Head.pm.html">MIME::Head</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="IO.pm.html">MIME::IO</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Latin1.pm.html">MIME::Latin1</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Parser.pm.html">MIME::Parser</A></SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="ParserBase.pm.html">MIME::ParserBase</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="ToolUtils.pm.html">MIME::ToolUtils</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Tools.pm.html">MIME::Tools</A></SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
<A HREF="Words.pm.html">MIME::Words</A></SMALL></B></TD>
</TABLE></CENTER>

<P><TABLE WIDTH="100%">

<TR VALIGN="TOP"><TD ALIGN="LEFT"><CENTER>
<H1><FONT SIZE=7 COLOR=#600020><B>MIME::<BR>Decoder</B></FONT></H1><IMG SRC="mime-sm.gif" ALT="MIME!"></CENTER>
<TD>
<UL>
<LI><A HREF="#name">NAME</A>
</LI><LI><A HREF="#synopsis">SYNOPSIS</A>
</LI><LI><A HREF="#description">DESCRIPTION</A>
</LI><LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
</LI><UL>
<LI><A HREF="#standard_interface">Standard interface</A>
</LI><LI><A HREF="#subclass_interface">Subclass interface</A>
</LI></UL>
<LI><A HREF="#decoder_subclasses">DECODER SUBCLASSES</A>
</LI><LI><A HREF="#notes">NOTES</A>
</LI><UL>
<LI><A HREF="#inputoutput_handles">Input/Output handles</A>
</LI><LI><A HREF="#writing_a_decoder">Writing a decoder</A>
</LI></UL>
<LI><A HREF="#author">AUTHOR</A>
</LI><LI><A HREF="#version">VERSION</A>
</LI></UL>

</TABLE>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder::Base64</SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder::Binary</SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder::Gzip64</SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder::NBit</SMALL></B></TD>

<TR>
<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder::QuotedPrint</SMALL></B></TD>

<TD WIDTH=25% ALIGN=CENTER><B><SMALL>
MIME::Decoder::UU</SMALL></B></TD>
</TABLE></CENTER>

<P>
<P><HR>
<A NAME="name">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NAME</FONT></H1>
</A>


<P>
MIME::Decoder - an object for decoding the body part of a MIME stream


<P><HR>
<A NAME="synopsis">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
SYNOPSIS</FONT></H1>
</A>


<P>
<B>Decoding a data stream.</B>
Here's a simple filter program to read quoted-printable data from STDIN
(until EOF) and write the decoded data to STDOUT:


<P>
<PRE>    use MIME::Decoder;</PRE>



<P>
<PRE>    &#36;decoder = new MIME::Decoder 'quoted-printable' or die &quot;unsupported&quot;;
    &#36;decoder-&gt;decode(\*STDIN, \*STDOUT);</PRE>



<P>
<B>Encoding a data stream.</B>
Here's a simple filter program to read binary data from STDIN
(until EOF) and write base64-encoded data to STDOUT:


<P>
<PRE>    use MIME::Decoder;</PRE>



<P>
<PRE>    &#36;decoder = new MIME::Decoder 'base64' or die &quot;unsupported&quot;;
    &#36;decoder-&gt;encode(\*STDIN, \*STDOUT);</PRE>



<P>
You can <B>write and install your own decoders</B> so that
MIME::Decoder will know about them:


<P>
<PRE>    use MyBase64Decoder;</PRE>



<P>
<PRE>    install MyBase64Decoder 'base64';</PRE>



<P>
You can also <B>test if an encoding is supported:</B>


<P>
<PRE>    if (supported MIME::Decoder 'x-uuencode') {
        # we can uuencode!
    }</PRE>



<P><HR>
<A NAME="description">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
DESCRIPTION</FONT></H1>
</A>


<P>
This abstract class, and its private concrete subclasses (see below)
provide an OO front end to the actions of...

<UL>

<P><LI>Decoding a MIME-encoded stream


<P><LI>Encoding a raw data stream into a MIME-encoded stream.

</UL>


<P>
The constructor for MIME::Decoder takes the name of an encoding
(<CODE>base64</CODE>, <CODE>7bit</CODE>, etc.), and returns an instance of a <I>subclass</I>
of MIME::Decoder whose <CODE>decode()</CODE> method will perform the appropriate
decoding action, and whose <CODE>encode()</CODE> method will perform the appropriate
encoding action.


<P><HR>
<A NAME="public_interface">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
PUBLIC INTERFACE</FONT></H1>
</A>


<P><HR>
<A NAME="standard_interface">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Standard interface</FONT></H2>
</A>


<P>
If all you are doing is <I>using</I> this class, here's all you'll need...

<DL>
<P><DT><B><A NAME="new">new ENCODING</A></B><DD>

<I>Class method, constructor.</I>
Create and return a new decoder object which can handle the 
given ENCODING.


<P>
<PRE>    my &#36;decoder = new MIME::Decoder &quot;7bit&quot;;</PRE>



<P>
Returns the undefined value if no known decoders are appropriate.


<P><DT><B><A NAME="best">best ENCODING</A></B><DD>

<I>Class method, constructor.</I>
Exactly like new(), except that this defaults any unsupported encoding to 
&quot;binary&quot;, after raising a suitable warning (it's a fatal error if there's 
no binary decoder).


<P>
<PRE>    my &#36;decoder = best MIME::Decoder &quot;x-gzip64&quot;;</PRE>



<P>
Will either return a decoder, or a raise a fatal exception.


<P><DT><B><A NAME="decode">decode INSTREAM,OUTSTREAM</A></B><DD>

<I>Instance method.</I>
Decode the document waiting in the input handle INSTREAM,
writing the decoded information to the output handle OUTSTREAM.


<P>
Read the section in this document on I/O handles for more information
about the arguments.  Note that you can still supply old-style
unblessed filehandles for INSTREAM and OUTSTREAM.


<P><DT><B><A NAME="encode">encode INSTREAM,OUTSTREAM</A></B><DD>

<I>Instance method.</I>
Encode the document waiting in the input filehandle INSTREAM,
writing the encoded information to the output stream OUTSTREAM.


<P>
Read the section in this document on I/O handles for more information
about the arguments.  Note that you can still supply old-style
unblessed filehandles for INSTREAM and OUTSTREAM.


<P><DT><B><A NAME="encoding">encoding</A></B><DD>

<I>Instance method.</I>
Return the encoding that this object was created to handle,
coerced to all lowercase (e.g., <CODE>&quot;base64&quot;</CODE>).


<P><DT><B><A NAME="head">head [HEAD]</A></B><DD>

<I>Instance method.</I>
Completely optional: some decoders need to know a little about the file 
they are encoding/decoding; e.g., x-uu likes to have the filename.
The HEAD is any object which responds to messages like:


<P>
<PRE>    &#36;head-&gt;mime_attr('content-disposition.filename');</PRE>



<P><DT><B><A NAME="supported">supported [ENCODING]</A></B><DD>

<I>Class method.</I>
With one arg (an ENCODING name), returns truth if that encoding
is currently handled, and falsity otherwise.  The ENCODING will
be automatically coerced to lowercase:


<P>
<PRE>    if (supported MIME::Decoder '7BIT') {
        # yes, we can handle it...
    }
    else {
        # drop back six and punt...
    } </PRE>



<P>
With no args, returns a reference to a hash of all available decoders,
where the key is the encoding name (all lowercase, like '7bit'),
and the value is true (it happens to be the name of the class 
that handles the decoding, but you probably shouldn't rely on that).
You may safely modify this hash; it will <I>not</I> change the way the 
module performs its lookups.  Only <CODE>install</CODE> can do that.


<P>
<I>Thanks to Achim Bohnet for suggesting this method.</I>

</DL>


<P><HR>
<A NAME="subclass_interface">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Subclass interface</FONT></H2>
</A>


<P>
If you are writing (or installing) a new decoder subclass, there
are some other methods you'll need to know about:

<DL>
<P><DT><B><A NAME="decode_it">decode_it INSTREAM,OUTSTREAM</A></B><DD>

<I>Abstract instance method.</I>  
The back-end of the <B>decode</B> method.  It takes an input handle
opened for reading (INSTREAM), and an output handle opened for
writing (OUTSTREAM).


<P>
If you are writing your own decoder subclass, you must override this
method in your class.  Your method should read from the input
handle via <CODE>getline()</CODE> or <CODE>read()</CODE>, decode this input, and print the
decoded data to the output handle via <CODE>print()</CODE>.  You may do this
however you see fit, so long as the end result is the same.


<P>
Note that unblessed references and globrefs are automatically turned
into I/O handles for you by <CODE>decode()</CODE>, so you don't need to worry
about it.


<P>
Your method must return either <CODE>undef</CODE> (to indicate failure),
or <CODE>1</CODE> (to indicate success).


<P><DT><B><A NAME="encode_it">encode_it INSTREAM,OUTSTREAM</A></B><DD>

<I>Abstract instance method.</I>  
The back-end of the <B>encode</B> method.  It takes an input handle
opened for reading (INSTREAM), and an output handle opened for
writing (OUTSTREAM).


<P>
If you are writing your own decoder subclass, you must override this
method in your class.  Your method should read from the input
handle via <CODE>getline()</CODE> or <CODE>read()</CODE>, encode this input, and print the
encoded data to the output handle via <CODE>print()</CODE>.  You may do this
however you see fit, so long as the end result is the same.


<P>
Note that unblessed references and globrefs are automatically turned
into I/O handles for you by <CODE>encode()</CODE>, so you don't need to worry
about it.


<P>
Your method must return either <CODE>undef</CODE> (to indicate failure),
or <CODE>1</CODE> (to indicate success).


<P><DT><B><A NAME="init">init ARGS...</A></B><DD>

<I>Instance method.</I>
Do any necessary initialization of the new instance,
taking whatever arguments were given to <CODE>new()</CODE>.
Should return the self object on success, undef on failure.


<P><DT><B><A NAME="install">install ENCODING</A></B><DD>

<I>Class method</I>.  
Install this class so that ENCODING is handled by it.
You should not override this method.


<P><DT><B><A NAME="filter">filter IN, OUT, COMMAND...</A></B><DD>

<I>Class method, utility.</I>
If your decoder involves an external program, you can invoke
them easily through this method.  The command must be a &quot;filter&quot;: a 
command that reads input from its STDIN (which will come from the IN argument)
and writes output to its STDOUT (which will go to the OUT argument).


<P>
For example, here's a decoder that un-gzips its data:


<P>
<PRE>    sub decode_it {
        my (&#36;self, &#36;in, &#36;out) = @_;
        &#36;self-&gt;filter(&#36;in, &#36;out, &quot;gzip -d -&quot;);
    }</PRE>



<P>
The usage is similar to IPC::Open2::open2 (which it uses internally), 
so you can specify COMMAND as a single argument or as an array.

</DL>


<P><HR>
<A NAME="decoder_subclasses">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
DECODER SUBCLASSES</FONT></H1>
</A>


<P>
You don't need to <CODE>&quot;use&quot;</CODE> any other Perl modules; the
following &quot;standard&quot; subclasses are included as part of MIME::Decoder:


<P>
<PRE>     Class:                         Handles encodings:
     ------------------------------------------------------------
     MIME::Decoder::Binary          binary
     MIME::Decoder::NBit            7bit, 8bit
     MIME::Decoder::Base64          base64
     MIME::Decoder::QuotedPrint     quoted-printable</PRE>



<P>
The following &quot;non-standard&quot; subclasses are also included:


<P>
<PRE>     Class:                         Handles encodings:
     ------------------------------------------------------------
     MIME::Decoder::UU              x-uu, x-uuencode
     MIME::Decoder::Gzip64          x-gzip64</PRE>



<P><HR>
<A NAME="notes">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NOTES</FONT></H1>
</A>


<P><HR>
<A NAME="inputoutput_handles">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Input/Output handles</FONT></H2>
</A>


<P>
As of MIME-tools 2.0, this class has to play nice with the new MIME::Body
class... which means that input and output routines cannot just assume that 
they are dealing with filehandles.


<P>
Therefore, all that MIME::Decoder and its subclasses require (and, thus, 
all that they can assume) is that INSTREAMs and OUTSTREAMs are objects 
which respond to a subset of the messages defined in the IO::Handle 
interface; minimally:


<P>
<PRE>      print
      getline
      read(BUF,NBYTES)</PRE>



<P>
For backwards compatibilty, if you supply a scalar filehandle name
(like <CODE>&quot;STDOUT&quot;</CODE>) or an unblessed glob reference (like <CODE>\*STDOUT</CODE>)
where an INSTREAM or OUTSTREAM is expected, this package will 
automatically wrap it in an object that fits these criteria, via IO::Wrap.


<P>
<I>Thanks to Achim Bohnet for suggesting this more-generic I/O model.</I>


<P><HR>
<A NAME="writing_a_decoder">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Writing a decoder</FONT></H2>
</A>


<P>
If you're experimenting with your own encodings, you'll probably want
to write a decoder.  Here are the basics:

<UL>

<P><LI><B>1.</B>
Create a module, like &quot;MyDecoder::&quot;, for your decoder.
Declare it to be a subclass of MIME::Decoder.


<P><LI><B>2.</B>
Create the following instance methods in your class, as described above:


<P>
<PRE>    decode_it
    encode_it
    init</PRE>



<P><LI><B>3.</B>
In your application program, activate your decoder for one or
more encodings like this:


<P>
<PRE>    require MyDecoder;</PRE>



<P>
<PRE>    install MyDecoder &quot;7bit&quot;;        # use MyDecoder to decode &quot;7bit&quot;    
    install MyDecoder &quot;x-foo&quot;;       # also, use MyDecoder to decode &quot;x-foo&quot;</PRE>


</UL>

<P>
To illustrate, here's a custom decoder class for the <CODE>quoted-printable</CODE> 
encoding:


<P>
<PRE>    package MyQPDecoder;</PRE>



<P>
<PRE>    @ISA = qw(MIME::Decoder);    
    use MIME::Decoder;
    use MIME::QuotedPrint;</PRE>



<P>
<PRE>    # decode_it - the private decoding method
    sub decode_it {
        my (&#36;self, &#36;in, &#36;out) = @_;</PRE>



<P>
<PRE>        while (defined(&#36;_ = &#36;in-&gt;getline)) {
            my &#36;decoded = decode_qp(&#36;_);
	    &#36;out-&gt;print(&#36;decoded);
        }
        1;
    }</PRE>



<P>
<PRE>    # encode_it - the private encoding method
    sub encode_it {
        my (&#36;self, &#36;in, &#36;out) = @_;</PRE>



<P>
<PRE>        my (&#36;buf, &#36;nread) = ('', 0); 
        while (&#36;in-&gt;read(&#36;buf, 60)) {
            my &#36;encoded = encode_qp(&#36;buf);
	    &#36;out-&gt;print(&#36;encoded);
        }
        1;
    }</PRE>



<P>
That's it.  The task was pretty simple because the <CODE>&quot;quoted-printable&quot;</CODE> 
encoding can easily be converted line-by-line... as can
even <CODE>&quot;7bit&quot;</CODE> and <CODE>&quot;8bit&quot;</CODE> (since all these encodings guarantee 
short lines, with a max of 1000 characters).
The good news is: it is very likely that it will be similarly-easy to 
write a MIME::Decoder for any future standard encodings.


<P>
The <CODE>&quot;binary&quot;</CODE> decoder, however, really required block reads and writes:
see <A HREF="#mimedecoderbinary">&quot;MIME::Decoder::Binary&quot;</A> for details.


<P><HR>
<A NAME="author">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
AUTHOR</FONT></H1>
</A>


<P>
Copyright (c) 1996,1997 by Eryq / eryq@zeegee.com


<P>
All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.


<P><HR>
<A NAME="version">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
VERSION</FONT></H1>
</A>


<P>
&#36;Revision: 4.105 &#36; &#36;Date: 1998/01/10 04:23:12 &#36;


<P><HR>
<SMALL>
		Last updated: Wed Jan 14 10:21:46 1998 <BR>
		Generated by pod2coolhtml 1.101.  Want a copy?  Just email
		<A HREF="mailto:eryq@enteract.com">eryq@enteract.com</A>.
		(Yes, it's free.)
		</SMALL></BODY>
</HTML>
