    <HTML>

    <HEAD>
    <TITLE>MIME::Head</TITLE>
    </HEAD>

<BODY  LINK="#C00000"    ALINK="#FF2020"  VLINK="#900000" >    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><A HREF="MIME-tools.html">Home</A></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Body.html">MIME::Body</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Decoder.html">MIME::Decoder</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Entity.html">MIME::Entity</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1 COLOR=#000000>MIME::Head</FONT></B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ParserBase.html">MIME::ParserBase</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#400000>MIME::<BR>Head</FONT></B></H1>
	    <img src="mime-sm.gif" alt="LOGO">
	    <P><FONT SIZE=+1 COLOR=#400000><I>It's MIME time!</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
	<UL>
		<LI><A HREF="#creation_input_and_output">Creation, input, and output</A>
		<LI><A HREF="#gettingsetting_fields">Getting/setting fields</A>
		<LI><A HREF="#mimespecific_methods">MIME-specific methods</A>
		<LI><A HREF="#compatibility_tweaks">Compatibility tweaks</A>
		</UL>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#design_issues">Design issues</A>
		</UL>
	<LI><A HREF="#warnings">WARNINGS</A>
	<UL>
		<LI><A HREF="#news_flash">NEWS FLASH! </A>
		<LI><A HREF="#upgrading_from_1x_to_2x">UPGRADING FROM 1.x to 2.x</A>
		</UL>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#version">VERSION</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
<A HREF="Head.html">MIME::Head</A> - MIME message header (a subclass of
Mail::Header)


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
Start off by requiring or using this package:


<P>

<PRE>
    require MIME::Head;
</PRE>

<P>

You can <STRONG>create</STRONG>
 a <A HREF="Head.html">MIME::Head</A> object in a number of ways:


<P>

<PRE>
    # Create a new, empty header, and populate it manually:    
    $head = MIME::Head-&gt;new;
    $head-&gt;set('content-type', 'text/plain; charset=US-ASCII');
    $head-&gt;set('content-length', $len);
    
    # Create a new header by parsing in the STDIN stream:
    $head = MIME::Head-&gt;read(\*STDIN);
    
    # Create a new header by parsing in a file:
    $head = MIME::Head-&gt;from_file(&quot;/tmp/test.hdr&quot;);
    
    # Create a new header by running a program:
    $head = MIME::Head-&gt;from_file(&quot;cat a.hdr b.hdr |&quot;);
</PRE>

<P>

To get rid of all internal newlines in all fields (called <STRONG>unfolding</STRONG>
):


<P>

<PRE>
    # Get rid of all internal newlines:
    $head-&gt;unfold();
</PRE>

<P>

To RFC-1522-decode any Q- or B-encoded-text in the header fields:


<P>

<PRE>
    $head-&gt;decode();
</PRE>

<P>

To test whether a given field <STRONG>exists</STRONG>
 (consider using the inherited
<CODE>count</CODE> method instead, though: <CODE>exists</CODE> has been deprecated, but will continue to work even if your MailTools is
old):


<P>

<PRE>
    # Was a &quot;Subject:&quot; given?
    if ($head-&gt;exists('subject')) {
        # yes, it does!
    }
</PRE>

<P>

To <STRONG>get the contents of a field,</STRONG>
 either a <EM>specific</EM>
 occurence (defaults to the first occurence in a scalar context) or <EM>all</EM>
 occurences (in an array context):


<P>

<PRE>
    # Is this a reply?
    $reply = 1 if ($head-&gt;get('Subject') =~ /^Re: /);
    
    # Get receipt information:
    print &quot;Last received from: &quot;, $head-&gt;get('Received', 0), &quot;\n&quot;;
    @all_received = $head-&gt;get('Received');
</PRE>

<P>

To <STRONG>get the first occurence</STRONG>
 of a field as a string, regardless of context:


<P>

<PRE>
    # Print the subject, or the empty string if none:
    print &quot;Subject: &quot;, $head-&gt;get('Subject',0), &quot;\n&quot;;
</PRE>

<P>

To <STRONG>get all occurences</STRONG>
 of a field as an array, regardless of context:


<P>

<PRE>
    # Too many hops?  Count 'em and see!
    if (int($head-&gt;get_all('Received')) &gt; 5) { ...
</PRE>

<P>

To <STRONG>set a field</STRONG>
 to a given string:


<P>

<PRE>
    # Declare this to be an HTML header:
    $head-&gt;replace('Content-type', 'text/html');
</PRE>

<P>

To get certain commonly-used <STRONG>MIME information</STRONG>
:


<P>

<PRE>
    # The content type (e.g., &quot;text/html&quot;):
    $mime_type     = $head-&gt;mime_type;
    
    # The content transfer encoding (e.g., &quot;quoted-printable&quot;):
    $mime_encoding = $head-&gt;mime_encoding;
    
    # The recommended filename (e.g., &quot;choosy-moms-choose.gif&quot;):
    $file_name     = $head-&gt;recommended_filename;
    
    # The boundary text, for multipart messages:
    $boundary      = $head-&gt;multipart_boundary;
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
A class for parsing in and manipulating RFC-822 message headers, with some
methods geared towards standard (and not so standard) MIME fields as
specified in RFC-1521, <EM>Multipurpose Internet Mail Extensions</EM>
.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="public_interface">PUBLIC INTERFACE</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="creation_input_and_output">Creation, input, and output</A></H3>
<DL>
<DT><STRONG><A NAME="item_new_argoptions">new [ARG],[OPTIONS]

</A></STRONG><DD>
<EM>Class method, inherited.</EM>

Creates a new header object. Arguments are the same as those in the
superclass.  


<P>

<DT><STRONG><A NAME="item_from_file_exproptions">from_file EXPR,OPTIONS

</A></STRONG><DD>
<EM>Class or instance method</EM>
. For convenience, you can use this to parse a header object in from EXPR,
which may actually be any expression that can be sent to
<CODE>open()</CODE> so as to return a readable filehandle. The ``file''
will be opened, read, and then closed:


<P>

<PRE>
    # Create a new header by parsing in a file:
    my $head = MIME::Head-&gt;from_file(&quot;/tmp/test.hdr&quot;);
</PRE>

<P>

Since this method can function as either a class constructor <EM>or</EM>
 
an instance initializer, the above is exactly equivalent to:


<P>

<PRE>
    # Create a new header by parsing in a file:
    my $head = MIME::Head-&gt;new-&gt;from_file(&quot;/tmp/test.hdr&quot;);
</PRE>

<P>

On success, the object will be returned; on failure, the undefined value.


<P>

The OPTIONS are the same as in <CODE>new(),</CODE> and are passed into
<CODE>new()</CODE> if this is invoked as a class method.


<P>

<STRONG>NOTE:</STRONG>
 This is really just a convenience front-end onto <CODE>read()</CODE>, provided mostly for backwards-compatibility with MIME-parser 1.0.


<P>

<DT><STRONG><A NAME="item_read_filehandle">read FILEHANDLE

</A></STRONG><DD>
<EM>Instance (or class) method.</EM>
 
This initiallizes a header object by reading it in from a FILEHANDLE, until
the terminating blank line is encountered. A syntax error or end-of-stream
will also halt processing.


<P>

Supply this routine with a reference to a filehandle glob; e.g., <CODE>\*STDIN</CODE>:


<P>

<PRE>
    # Create a new header by parsing in STDIN:
    $head-&gt;read(\*STDIN);
</PRE>

<P>

On success, the self object will be returned; on failure, a false value.


<P>

<STRONG>Note:</STRONG>
 in the MIME world, it is perfectly legal for a header to be empty,
consisting of nothing but the terminating blank line. Thus, we can't just
use the formula that ``no tags equals error''.


<P>

<STRONG>Warning:</STRONG>
 as of the time of this writing, Mail::Header::read did not flag either
syntax errors or unexpected end-of-file conditions (an EOF before the
terminating blank line). <A HREF="ParserBase.html">MIME::ParserBase</A>
takes this into account.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="gettingsetting_fields">Getting/setting fields</A></H3>
The following are methods related to retrieving and modifying the header
fields. Some are inherited from Mail::Header, but I've kept the
documentation around for convenience.


<P>

<DL>
<DT><STRONG><A NAME="item_add_tagtextindex">add TAG,TEXT,[INDEX]

</A></STRONG><DD>
<EM>Instance method, inherited.</EM>

Add a new occurence of the field named TAG, given by TEXT:


<P>

<PRE>
    # Add the trace information:    
    $head-&gt;add('Received', 'from eryq.pr.mcs.net by gonzo.net with smtp');
</PRE>

<P>

Normally, the new occurence will be <EM>appended</EM>
 to the existing occurences. However, if the optional INDEX argument is 0,
then the new occurence will be <EM>prepended</EM>
. If you want to be <EM>explicit</EM>
 
about appending, specify an INDEX of -1.


<P>

<STRONG>NOTE:</STRONG>
 use of ``BEFORE'' (for index 0) or ``AFTER'' (for index -1) is still
allowed, but deprecated.


<P>

<STRONG>WARNING</STRONG>
: this method always adds new occurences; it doesn't overwrite any existing
occurences... so if you just want to <EM>change</EM>
 the value of a field (creating it if necessary), then you probably <STRONG>don't</STRONG>
 want to use this method: consider using <A HREF="#item_set">set</A> instead.


<P>

<DT><STRONG><A NAME="item_decode">decode

</A></STRONG><DD>
<EM>Instance method.</EM>

Go through all the header fields, looking for RFC-1522-style ``Q''
(quoted-printable, sort of) or ``B'' (base64) encoding, and decode them
in-place. Fellow Americans, you probably don't know what the hell I'm
talking about. Europeans, Russians, et al, you probably do.  <CODE>:-)</CODE>. 


<P>

For example, here's a valid header you might get:


<P>

<PRE>
      From: =?US-ASCII?Q?Keith_Moore?= &lt;moore@cs.utk.edu&gt;
      To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;
      CC: =?ISO-8859-1?Q?Andr=E9_?= Pirard &lt;PIRARD@vm1.ulg.ac.be&gt;
      Subject: =?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
       =?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
       =?US-ASCII?Q?.._cool!?=
</PRE>

<P>

That basically decodes to (sorry, I can only approximate the Latin
characters with 7 bit sequences /o and 'e):


<P>

<PRE>
      From: Keith Moore &lt;moore@cs.utk.edu&gt;
      To: Keld J/orn Simonsen &lt;keld@dkuug.dk&gt;
      CC: Andr'e  Pirard &lt;PIRARD@vm1.ulg.ac.be&gt;
      Subject: If you can read this you understand the example... cool!
</PRE>

<P>

<STRONG>NOTE:</STRONG>
 currently, the decodings are done without regard to the character set:
thus, the Q-encoding <CODE>=F8</CODE> is simply translated to the octet (hexadecimal <CODE>F8</CODE>), period. Perhaps this is a bad idea; I honestly don't know. Certainly, a
mail <EM>reader</EM>
 intended for humans should use the raw (undecoded) header. But a mail
robot? Anyway, I'll gladly take guidance from anyone who has a clear idea
of what should happen.


<P>

<STRONG>WARNING:</STRONG>
 the CRLF+SPACE separator that splits up long encoded words into shorter
sequences (see the Subject: example above) gets lost when the field is
unfolded, and so decoding after unfolding causes a spurious space to be
left in the field.  
<EM>THEREFORE: if you're going to decode, do so BEFORE unfolding!</EM>





<P>

This method returns the self object.


<P>

<EM>Thanks to Kent Boortz for providing the idea, and the baseline
RFC-1522-decoding code!</EM>





<P>

<DT><STRONG><A NAME="item_delete_tagindex">delete TAG,[INDEX]

</A></STRONG><DD>
<EM>Instance method, inherited.</EM>

Delete all occurences of the field named TAG.


<P>

<PRE>
    # Remove all the MIME information:
    $head-&gt;delete('MIME-Version');
    $head-&gt;delete('Content-type');
    $head-&gt;delete('Content-transfer-encoding');
    $head-&gt;delete('Content-disposition');
</PRE>

<P>

<DT><STRONG><A NAME="item_exists_tag">exists TAG

</A></STRONG><DD>
<EM>Instance method, inherited, DEPRECATED.</EM>

Returns whether a given field exists:


<P>

<PRE>
    # Was a &quot;Subject:&quot; given?
    if ($head-&gt;exists('subject')) {
        # yes, it does!
    }
</PRE>

<P>

The TAG is treated in a case-insensitive manner. This method returns some
false value if the field doesn't exist, and some true value if it does.


<P>

<STRONG>DEPRECATED</STRONG>
 by Mail::Header v.1.06. If you have a recent copy of Mail::Header, you
should use <CODE>count()</CODE> instead, which returns equivalent boolean
values. <A HREF="Head.html">MIME::Head::exists</A> uses
<CODE>count()</CODE> if it's available, but <CODE>exists()</CODE> is
currently kept without warning for backwards-compatibility (since we don't
want to demand that you have <CODE>count()).</CODE>


<P>

<DT><STRONG><A NAME="item_get_tagindex">get TAG,[INDEX]

</A></STRONG><DD>
<EM>Instance method, inherited.</EM>
  
Get the contents of field TAG.


<P>

If a <STRONG>numeric INDEX</STRONG>
 is given, returns the occurence at that index, or undef if not present:


<P>

<PRE>
    # Print the first 'Received:' entry (explicitly):
    print &quot;Most recent: &quot;, $head-&gt;get('received',0), &quot;\n&quot;;
   
    # Print the last 'Received:' entry:
    print &quot;Least recent: &quot;, $head-&gt;get('received', -1), &quot;\n&quot;; 
</PRE>

<P>

If <STRONG>no INDEX</STRONG>
 is given, but invoked in a <STRONG>scalar</STRONG>
 context, then INDEX simply defaults to 0:


<P>

<PRE>
    # Get the first 'Received:' entry (implicitly):
    my $most_recent = $head-&gt;get('received');
</PRE>

<P>

If <STRONG>no INDEX</STRONG>
 is given, and invoked in an <STRONG>array</STRONG>
 context, then
<EM>all</EM>
 occurences of the field are returned:


<P>

<PRE>
    # Get all 'Received:' entries:
    my @all_received = $head-&gt;get('received');
</PRE>

<P>

<STRONG>WARNING:</STRONG>
  <EM>This has changed since MIME-parser 1.x. You should now use the two-argument
form if you want the old behavior, or else tweak the module to emulate
version 1.0.</EM>





<P>

<DT><STRONG><A NAME="item_get_all_field">get_all FIELD

</A></STRONG><DD>
<EM>Instance method.</EM>

Returns the list of <EM>all</EM>
 occurences of the field, or the empty list if the field is not present:


<P>

<PRE>
    # How did it get here?
    @history = $head-&gt;get_all('Received');
</PRE>

<P>

<STRONG>NOTE:</STRONG>
 I had originally experimented with having <CODE>get()</CODE> return all occurences when invoked in an array context... but that causes a
lot of accidents when you get careless and do stuff like this:


<P>

<PRE>
    print &quot;\u$field: &quot;, $head-&gt;get($field), &quot;\n&quot;;
</PRE>

<P>

It also made the intuitive behaviour unclear if the INDEX argument was
given in an array context. So I opted for an explicit approach to asking
for all occurences.


<P>

<DT><STRONG><A NAME="item_original_text">original_text

</A></STRONG><DD>
<EM>Instance method.</EM>

Recover the original text that was <CODE>read()</CODE> in to create this
object:


<P>

<PRE>
    print &quot;PARSED FROM:\n&quot;, $head-&gt;original_text;    
</PRE>

<P>

<STRONG>WARNING:</STRONG>
 does no such thing now. Just returns a reasonable approximation of that
text. Think of it as nothing more than a poorly-named
<CODE>as_string()</CODE> method, which outputs the header fields in the order received. Provided for
backwards-compatibility only.


<P>

This method depends on Mail::Header::header returning the information in
the proper order.


<P>

<DT><STRONG><A NAME="item_print_filehandle">print [FILEHANDLE]

</A></STRONG><DD>
<EM>Instance method, inherited.</EM>

Print the header out to the given filehandle.


<P>

<DT><STRONG><A NAME="item_set_tagtext">set TAG,TEXT

</A></STRONG><DD>
<EM>Instance method.</EM>

Set the field named TAG to [the single occurence given by the TEXT:


<P>

<PRE>
    # Set the MIME type:
    $head-&gt;set('content-type', 'text/html');
    
The TAG is treated in a case-insensitive manner.
</PRE>

<P>

<STRONG>DEPRECATED.</STRONG>
  Use <CODE>replace()</CODE> instead.


<P>

<DT><STRONG><A NAME="item_unfold_field">unfold [FIELD]

</A></STRONG><DD>
<EM>Instance method, inherited.</EM>

Unfold the text of all occurences of the given FIELD. If the FIELD is
omitted, <EM>all</EM>
 fields are unfolded.


<P>

``Unfolding'' is the act of removing all newlines.


<P>

<PRE>
    $head-&gt;unfold;
</PRE>

<P>

Returns the ``self'' object.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="mimespecific_methods">MIME-specific methods</A></H3>
All of the following methods extract information from the following fields:


<P>

<PRE>
    Content-type
    Content-transfer-encoding
    Content-disposition
</PRE>

<P>

Be aware that they do not just return the raw contents of those fields, and
in some cases they will fill in sensible (I hope) default values. Use <CODE>get()</CODE> if you need to grab and process the raw field text.


<P>

<STRONG>NOTE:</STRONG>
 some of these methods are provided both as a convenience and for
backwards-compatibility only, while others (like <A
HREF="#item_recommended_filename">recommended_filename</A> <EM>really do have to be in <A HREF="Head.html">MIME::Head</A> to work
properly,</EM>
 since they look for their value in more than one field. However, if you
know that a value is restricted to a single field, you should really use
the Mail::Field interface to get it.


<P>

<DL>
<DT><STRONG><A NAME="item_mime_encoding">mime_encoding

</A></STRONG><DD>
<EM>Instance method.</EM>

Try <EM>real hard</EM>
 to determine the content transfer encoding (e.g., <CODE>"base64"</CODE>, <CODE>"binary"</CODE>), which is returned in all-lowercase.


<P>

If no encoding could be found, the default of <CODE>"7bit"</CODE> is returned. I quote from RFC-1521 section 5:


<P>

<PRE>
    This is the default value -- that is, &quot;Content-Transfer-Encoding: 7BIT&quot; 
    is assumed if the Content-Transfer-Encoding header field is not present.
</PRE>

<P>

<DT><STRONG><A NAME="item_mime_type">mime_type

</A></STRONG><DD>
<EM>Instance method.</EM>

Try <CODE>real hard</CODE> to determine the content type (e.g., <CODE>"text/plain"</CODE>,
<CODE>"image/gif"</CODE>, <CODE>"x-weird-type"</CODE>, which is returned in all-lowercase.  


<P>

If no content type could be found, the default of <CODE>"text/plain"</CODE> 
is returned. I quote from RFC-1521 section 7.1:


<P>

<PRE>
    The default Content-Type for Internet mail is 
    &quot;text/plain; charset=us-ascii&quot;.
</PRE>

<P>

<DT><STRONG><A NAME="item_multipart_boundary">multipart_boundary

</A></STRONG><DD>
<EM>Instance method.</EM>

If this is a header for a multipart message, return the ``encapsulation
boundary'' used to separate the parts. The boundary is returned exactly as
given in the <CODE>Content-type:</CODE> field; that is, the leading double-hyphen (<CODE>--</CODE>) is <EM>not</EM>
 prepended.


<P>

(Well, <EM>almost</EM>
 exactly... from RFC-1521:


<P>

<PRE>
   (If a boundary appears to end with white space, the white space 
   must be presumed to have been added by a gateway, and must be deleted.)  
</PRE>

<P>

so we oblige and remove any trailing spaces.)


<P>

Returns undef (<STRONG>not</STRONG>
 the empty string) if either the message is not multipart, if there is no
specified boundary, or if the boundary is illegal (e.g., if it is empty
after all trailing whitespace has been removed).


<P>

<DT><STRONG><A NAME="item_recommended_filename">recommended_filename

</A></STRONG><DD>
<EM>Instance method.</EM>

Return the recommended external filename. This is used when extracting the
data from the MIME stream.


<P>

Returns undef if no filename could be suggested.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="compatibility_tweaks">Compatibility tweaks</A></H3>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="design_issues">Design issues</A></H3>
<DL>
<DT><STRONG><A NAME="item_why_have_separate_objects_for_th">Why have separate objects for the entity, head, and body?

</A></STRONG><DD>
See the documentation for the MIME-parser distribution for the rationale
behind this decision.


<P>

<DT><STRONG><A NAME="item_why_assume_that_mime_headers_are">Why assume that MIME headers are email headers?

</A></STRONG><DD>
I quote from Achim Bohnet, who gave feedback on v.1.9 (I think he's using
the word <EM>header</EM>
 where I would use <EM>field</EM>
; e.g., to refer to ``Subject:'', ``Content-type:'', etc.):


<P>

<PRE>
    There is also IMHO no requirement [for] MIME::Heads to look 
    like [email] headers; so to speak, the MIME::Head [simply stores] 
    the attributes of a complex object, e.g.:
</PRE>

<P>

<PRE>
        new MIME::Head type =&gt; &quot;text/plain&quot;,
                       charset =&gt; ...,
                       disposition =&gt; ..., ... ;
</PRE>

<P>

I agree in principle, but (alas and dammit) RFC-1521 says otherwise.
RFC-1521 [MIME] headers are a syntactic subset of RFC-822 [email] headers.
Perhaps a better name for these modules would be RFC1521:: instead of
MIME::, but we're a little beyond that stage now.


<P>

In my mind's eye, I see an abstract class, call it <A
HREF="Attrs.html">MIME::Attrs,</A> which does what Achim suggests... so you
could say:


<P>

<PRE>
     my $attrs = new MIME::Attrs type =&gt; &quot;text/plain&quot;,
				 charset =&gt; ...,
                                 disposition =&gt; ..., ... ;
</PRE>

<P>

We could even make it a superclass of <A HREF="Head.html">MIME::Head:</A>
that way, <A HREF="Head.html">MIME::Head</A> would have to implement its
interface, <EM>and</EM>
 allow itself to be initiallized from a <A HREF="Attrs.html">MIME::Attrs</A>
object.


<P>

However, when you read RFC-1521, you begin to see how much MIME information
is organized by its presence in particular fields. I imagine that we'd
begin to mirror the structure of RFC-1521 fields and subfields to such a
degree that this might not give us a tremendous gain over just having <A
HREF="Head.html">MIME::Head.</A>


<P>

<DT><STRONG><A NAME="item_why_all_this_occurence_and_index">Why all this ''occurence`` and ''index`` jazz? Isn't every field unique?

</A></STRONG><DD>
Aaaaaaaaaahh....no.


<P>

(This question is generic to all Mail::Header subclasses, but I'll field it
here...)


<P>

Looking at a typical mail message header, it is sooooooo tempting to just
store the fields as a hash of strings, one string per hash entry.
Unfortunately, there's the little matter of the <CODE>Received:</CODE> field, which (unlike <CODE>From:</CODE>, <CODE>To:</CODE>, etc.) will often have multiple occurences; e.g.:


<P>

<PRE>
    Received: from gsfc.nasa.gov by eryq.pr.mcs.net  with smtp
        (Linux Smail3.1.28.1 #5) id m0tStZ7-0007X4C; Thu, 21 Dec 95 16:34 CST
    Received: from rhine.gsfc.nasa.gov by gsfc.nasa.gov (5.65/Ultrix3.0-C)
        id AA13596; Thu, 21 Dec 95 17:20:38 -0500
    Received: (from eryq@localhost) by rhine.gsfc.nasa.gov (8.6.12/8.6.12) 
        id RAA28069; Thu, 21 Dec 1995 17:27:54 -0500
    Date: Thu, 21 Dec 1995 17:27:54 -0500
    From: Eryq &lt;eryq@rhine.gsfc.nasa.gov&gt;
    Message-Id: &lt;199512212227.RAA28069@rhine.gsfc.nasa.gov&gt;
    To: eryq@eryq.pr.mcs.net
    Subject: Stuff and things
</PRE>

<P>

The <CODE>Received:</CODE> field is used for tracing message routes, and although it's not generally
used for anything other than human debugging, I didn't want to
inconvenience anyone who actually wanted to get at that information.  


<P>

I <EM>also</EM>
 didn't want to make this a special case; after all, who knows what <STRONG>other</STRONG>
 fields could have multiple occurences in the future? So, clearly, multiple
entries had to somehow be stored multiple times... and the different
occurences had to be retrievable.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="warnings">WARNINGS</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="news_flash">NEWS FLASH! </A></H3>
Rejoice! As of MIME-parser 2.0, this is a subclass of Mail::Header, as the
Maker of All Things intended. It will continue to exist, both for
backwards-compatibility with MIME-parser 1.0, and to allow me to tinker
with MIME-specific methods.


<P>

If you are upgrading from the MIME-parser 1.0 package, and you used this
module directly, you may notice some warnings about deprecated constructs
in your code... all your stuff should (hopefully) still work... you'll just
see a lot of warnings.  
<STRONG>However, you should read the <STRONG>COMPATIBILITY TWEAKS</STRONG> and
<STRONG>WARNINGS</STRONG> sections before installing it!</STRONG>
 

 


<P>

I have also changed terminology to match with the new MailTools
distribution. Thus, the <EM>name</EM>
 of a field (``Subject'', ``From'', ``To'', etc.) is now called a <STRONG>``tag''</STRONG>
 instead of a ``field''.


<P>

However, I have retained all the documentation where appropriate, even when
inheriting from the Mail::Header module. Hopefully, you won't need to flip
back and forth between man pages to use this module.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="upgrading_from_1x_to_2x">UPGRADING FROM 1.x to 2.x</A></H3>
<DL>
<DT><STRONG><A NAME="item_altered_methodsusage">Altered methods/usage

</A></STRONG><DD>
There are things you must beware of if you are either a MIME-parser 1.x
user or a Mail::Header user:


<P>

<DL>
<DT><STRONG><A NAME="item_modified_get_behavior">Modified <CODE>get()</CODE> behavior

</A></STRONG><DD>
In the old system, always <CODE>get()</CODE> returned a single value, and <CODE>get_all()</CODE>
returned multiple values: array vs. scalar context was not used.


<P>

Since Mail::Header does stuff differently, we have to obey our superclass
or we might break some of its complex methods that use <CODE>get()</CODE>
(like <CODE>Mail::Header::combine()</CODE>, which expects <CODE>get()</CODE> to return all fields in an array context). Unfortunately, this will break
some of <EM>your</EM>
 old code. 


<P>

<STRONG>For now,</STRONG>
 you can tell the system to emulate the MIME-parser version 1 behavior.


<P>

<STRONG>For future compatibility,</STRONG>
 you should, as soon as possible, modify your code to use the two-arg form
of <CODE>get</CODE> if you want a single value, with the second arg being 0. This does what the
old <CODE>get()</CODE> method did:


<P>

<PRE>
    print &quot;Subject: &quot;,  $head-&gt;get('subject',0), &quot;\n&quot;;
</PRE>

<P>

</DL>
<DT><STRONG><A NAME="item_deprecated_methodsusage">Deprecated methods/usage

</A></STRONG><DD>
The following are deprecated as of MIME-parser v.2.0. In many cases, they
are redundant with Mail::Header subroutines of different names:


<P>

<DL>
<DT><STRONG><A NAME="item_add">add

</A></STRONG><DD>
Use numeric index 0 for 'BEFORE' and -1 for 'AFTER'.


<P>

<DT><STRONG><A NAME="item_add_text">add_text

</A></STRONG><DD>
If you really need this, use the inherited <CODE>replace()</CODE> method instead. The current implementation is now somewhat inefficient.


<P>

<DT><STRONG><A NAME="item_copy">copy

</A></STRONG><DD>
Use the inherited <CODE>dup()</CODE> method instead.


<P>

<DT><STRONG><A NAME="item_fields">fields

</A></STRONG><DD>
Use the inherited <CODE>tags()</CODE> method instead.  <STRONG>Beware:</STRONG>
 that method does not automatically downcase its output for you: you will
have to do that yourself.


<P>

<DT><STRONG><A NAME="item_params">params

</A></STRONG><DD>
Use the new <A HREF="Field.html">MIME::Field</A> interface classes
(subclasses of Mail::Field) to access portions of a structured MIME field.


<P>

<DT><STRONG><A NAME="item_set">set

</A></STRONG><DD>
Use the inherited <CODE>replace()</CODE> method instead.


<P>

<DT><STRONG><A NAME="item_tweak_from_parsing">tweak_FROM_parsing 

</A></STRONG><DD>
Use the inherited <CODE>mail_from()</CODE> method instead.


<P>

</DL>
</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR</A></H2>
Copyright (c) 1996 by Eryq / <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A>  


<P>

All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


<P>

The more-comprehensive filename extraction is courtesy of Lee E. Brotzman,
Advanced Data Solutions.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="version">VERSION</A></H2>
$Revision: 3.202 $ $Date: 1997/01/22 05:00:29 $


<P>

</BODY>
</HTML>
