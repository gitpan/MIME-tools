    <HTML>

    <HEAD>
    <TITLE>MIME-tools</TITLE>
    </HEAD>

<BODY  LINK="#C00000"    ALINK="#FF2020"  VLINK="#900000" >    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><FONT COLOR=##000000>Home</FONT></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Body.html">MIME::Body</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Decoder.html">MIME::Decoder</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Entity.html">MIME::Entity</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Head.html">MIME::Head</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ParserBase.html">MIME::ParserBase</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#400000>MIME-tools</FONT></B></H1>
	    <img src="mime-lg.gif" alt="LOGO">
	    <P><FONT SIZE=+1 COLOR=#400000><I>It's MIME time!</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#a_quick_tour">A QUICK TOUR</A>
	<UL>
		<LI><A HREF="#parsing_in_a_nutshell">Parsing, in a nutshell</A>
		<LI><A HREF="#composing_in_a_nutshell">Composing, in a nutshell</A>
		<LI><A HREF="#other_stuff">Other stuff</A>
		</UL>
	<LI><A HREF="#contents">CONTENTS</A>
	<UL>
		<LI><A HREF="#modules_in_this_toolkit">Modules in this toolkit</A>
		<LI><A HREF="#programs_in_this_toolkit">Programs in this toolkit</A>
		</UL>
	<LI><A HREF="#manifest">MANIFEST</A>
	<LI><A HREF="#requirements">REQUIREMENTS</A>
	<LI><A HREF="#installation">INSTALLATION</A>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#compatibility">Compatibility</A>
		<LI><A HREF="#design_issues">Design issues</A>
		<LI><A HREF="#questionable_practices">Questionable practices</A>
		</UL>
	<LI><A HREF="#change_log">CHANGE LOG</A>
	<UL>
		<LI><A HREF="#current_events">Current events</A>
		<LI><A HREF="#ancient_history">Ancient history</A>
		<LI><A HREF="#future_plans">Future plans</A>
		</UL>
	<LI><A HREF="#terms_and_conditions">TERMS AND CONDITIONS</A>
	<LI><A HREF="#support">SUPPORT</A>
	<LI><A HREF="#author">AUTHOR </A>
	<LI><A HREF="#acknowledgments">ACKNOWLEDGMENTS</A>
	<LI><A HREF="#see_also">SEE ALSO</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
MIME-tools - modules for parsing (and creating!) MIME entities


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
Here's some pretty basic code for <STRONG>parsing a MIME message,</STRONG>
 and outputting its decoded components to a given directory:


<P>

<PRE>
    use MIME::Parser;
     
    # Create parser, and set the output directory:
    my $parser = new MIME::Parser;
    $parser-&gt;output_dir(&quot;$ENV{HOME}/mimemail&quot;);
     
    # Parse input:
    $entity = $parser-&gt;read(\*STDIN) or die &quot;couldn't parse MIME stream&quot;;
    
    # Take a look at the top-level entity (and any parts it has):
    $entity-&gt;dump_skeleton; 
</PRE>

<P>

Here's some code which <STRONG>composes and sends a MIME message</STRONG>
 containing three parts: a text file, an attached GIF, and some more text:


<P>

<PRE>
    use MIME::Entity;
</PRE>

<P>

<PRE>
    # Create the top-level, and set up the mail headers:
    $top = build MIME::Entity Type   =&gt;&quot;multipart/mixed&quot;,
                              -From    =&gt; &quot;me\@myhost.com&quot;,
	                      -To      =&gt; &quot;you\@yourhost.com&quot;,
                              -Subject =&gt; &quot;Hello, nurse!&quot;;
    
    # Attachment #1: a simple text document: 
    attach $top  Path=&gt;&quot;./testin/short.txt&quot;;
    
    # Attachment #2: a GIF file:
    attach $top  Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                 Type        =&gt; &quot;image/gif&quot;,
                 Encoding    =&gt; &quot;base64&quot;;
        
    # Attachment #3: some literal text:
    attach $top  Data=&gt;$message;
    
    # Send it:
    open MAIL, &quot;| /usr/lib/sendmail -t -i&quot; or die &quot;open: $!&quot;;
    $top-&gt;print(\*MAIL);
    close MAIL;
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
MIME-tools is a collection of Perl5 MIME:: modules for parsing, decoding,
<EM>and generating</EM>
 single- or multipart (even nested multipart) MIME messages. (Yes, kids,
that means you can send messages with attached GIF files).


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="a_quick_tour">A QUICK TOUR</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="parsing_in_a_nutshell">Parsing, in a nutshell</A></H3>
You usually start by creating an instance of <STRONG><A HREF="Parser.html">MIME::Parser</A></STRONG>
 (a subclass of the abstract <STRONG><A HREF="ParserBase.html">MIME::ParserBase</A></STRONG>
), and setting up certain parsing parameters: what directory to save
extracted files to, how to name the files, etc.


<P>

You then give that instance a readable filehandle on which waits a MIME
message. If all goes well, you will get back a <STRONG><A HREF="Entity.html">MIME::Entity</A></STRONG>

object (a subclass of <STRONG>Mail::Internet</STRONG>
), which consists of...


<P>

<UL>
<LI><STRONG></STRONG>
A <STRONG><A HREF="Head.html">MIME::Head</A></STRONG>
 (a subclass of <STRONG>Mail::Header</STRONG>
) which holds the MIME header data.


<P>

<LI><STRONG></STRONG>
A <STRONG><A HREF="Body.html">MIME::Body</A></STRONG>
, which is a object that knows where the body data is. You ask this object
to ``open'' itself for reading, and it will hand you back an ``I/O handle''
for reading the data: this is a FileHandle-like object, and could be of any
class, so long as it conforms to a subset of the <STRONG>IO::Handle</STRONG>
 interface.  


<P>

</UL>
If the original message was a multipart document, the <A
HREF="Entity.html">MIME::Entity</A> object will have a non-empty list of
``parts'', each of which is in turn a <A
HREF="Entity.html">MIME::Entity</A> (which might also be a multipart
entity, etc, etc...).


<P>

Internally, the parser (in <A HREF="ParserBase.html">MIME::ParserBase)</A>
asks for instances of <STRONG><A HREF="Decoder.html">MIME::Decoder</A></STRONG>
 whenever it needs to decode an encoded file. <A
HREF="Decoder.html">MIME::Decoder</A> has a mapping from supported
encodings (e.g., 'base64') to classes whose instances can decode them. You
can add to this mapping to try out new/experiment encodings. You can also
use <A HREF="Decoder.html">MIME::Decoder</A> by itself.  


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="composing_in_a_nutshell">Composing, in a nutshell</A></H3>
On a small scale, the <A HREF="Decoder.html">MIME::Decoder</A> can be used
to <EM>encode</EM>
 as well. All the standard encodings are supported: 


<P>

<PRE>
    7bit               Use this for plain ASCII documents (and multiparts)
    8bit               
    binary             
    quoted-printable   Use this for text files with 8-bit characters
    base64             Use this for binary files
</PRE>

<P>

When encoding a text document as a <CODE>7bit</CODE> mail message, the software will not puke on 8-bit characters... instead,
the 8-bit characters are escaped for you into reasonable ASCII sequences,
by the 
<STRONG><A HREF="Latin1.html">MIME::Latin1</A></STRONG>
 module. This feature is for folks who really hate sending out a document as
quoted-printable just because it happens to have a couple of French or
German names.


<P>

I've considered making it so that the content-type and encoding can be
automatically inferred from the file's path, but that seems to be asking
for trouble... or at least, for Mail::Cap...


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="other_stuff">Other stuff</A></H3>
If you want to tweak the way this toolkit works (for example, to turn on
debugging), use the routines in the <STRONG><A HREF="ToolUtils.html">MIME::ToolUtils</A></STRONG>
 module.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="contents">CONTENTS</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="modules_in_this_toolkit">Modules in this toolkit</A></H3>
<PRE>
    Module       DSLI   Description                                  Info
    ----------   ----   ------------------------------------------   ----
    MIME::
    ::Body       adpO   Abstract message holder (file, scalar, etc.) ERYQ
    ::Decoder    bdpO   OO interface for decoding MIME messages      ERYQ
    ::Entity     bdpO   An extracted and decoded MIME entity         ERYQ
    ::Field::*   bdpO   Mail::Field subclasses for parsing fields    ERYQ
    ::Head       bdpO   A parsed MIME header (Mail::Header subclass) ERYQ
    ::IO         adpO   Simple I/O handles for filehandles/scalars   ERYQ
    ::Latin1     adpO   Encoding 8-bit Latin-1 as 7-bit ASCII        ERYQ
    ::Parser     bdpO   Parses streams to create MIME entities       ERYQ
    ::ParserBase bdpO   For building your own MIME parser            ERYQ
    ::ToolUtils  adpO   For tweaking the MIME-tools library          ERYQ
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="programs_in_this_toolkit">Programs in this toolkit</A></H3>
<PRE>
    mimedump    - dump out a summary of the contents of a MIME message
    mimeexplode - parse/decode a MIME message into its component files
    mimesend    - send a message with attachments from the command line
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="manifest">MANIFEST</A></H2>
<PRE>
    ./MIME/*.pm         the MIME-tools classes
    ./Makefile.PL       the input to MakeMaker
    ./COPYING           terms and conditions for copying/using the software
    ./README            this file
    ./docs/             HTMLized documentation
    ./etc/              convenient copies of other modules you may need
    ./examples          sample executables
    ./t/*.t             the &quot;make test&quot; scripts
    ./testin/           files you can use for testing (as in &quot;make test&quot;)
    ./testout/          the output of &quot;make test&quot;
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="requirements">REQUIREMENTS</A></H2>
You'll need <STRONG>Perl5.002</STRONG>
 or better.


<P>

You'll need to obtain and install the following kits from the CPAN:


<P>

<DL>
<DT><STRONG><A NAME="item_mimequotedprint_base64">MIME::(QuotedPrint, Base64)

</A></STRONG><DD>
These perform the low-level MIME decoding. Get these from <STRONG>Gisle Aas'</STRONG>
 author directory. They are also reported to be in the LWP distribution.


<P>

<DT><STRONG><A NAME="item_mailtools_106_or_higher">MailTools (1.06 or higher)

</A></STRONG><DD>
This is <STRONG>Graham Barr's</STRONG>
 revamped set of Mail:: modules. Many of them are now superclasses of the
MIME:: modules, and perform the core functionality of manipulating headers
and fields.


<P>

</DL>
<STRONG>For your convenience,</STRONG>
 possibly-old copies of the MIME:: modules are provided in the ./etc
directory, of the distribution, but they are NOT installed for you during
the installation procedure.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="installation">INSTALLATION</A></H2>
Pretty simple:


<P>

<PRE>
    1. Gunzip and de-tar the distribution, and cd to the top level.
    2. Type:      perl Makefile.PL
    3. Type:      make                    # this step is optional
    4. Type:      make test               # this step is optional
    5. Type:      make install
</PRE>

<P>

Other interesting targets in the Makefile are:


<P>

<PRE>
    make config     # to check if the Makefile is up-to-date
    make clean      # delete local temp files (Makefile gets renamed)
    make realclean  # delete derived files (including ./blib)
</PRE>

<P>

If you're installing this as a replacment for MIME-parser 1.x or earlier,
<EM>please</EM>
 read the <A HREF="#compatibility">Compatibility</A>
 notes.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="compatibility">Compatibility</A></H3>
If you're installing this as a replacement for the MIME-parser 1.x release,
and you really don't want to break existing code, you should do this at any
point before the parsing code is invoked:


<P>

<PRE>
    use MIME::ToolUtils;
    
    MIME::ToolUtils-&gt;emulate_version(1.0);
</PRE>

<P>

Try not to get too attached to this, though. Instead, plan on upgrading
your code ASAP to the 2.0 style.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="design_issues">Design issues</A></H3>
<DL>
<DT><STRONG><A NAME="item_why_assume_that_mime_objects_are">Why assume that MIME objects are email objects?

</A></STRONG><DD>
I quote from Achim Bohnet, who gave feedback on v.1.9 (I think he's using
the word <EM>header</EM>
 where I would use <EM>field</EM>
; e.g., to refer to ``Subject:'', ``Content-type:'', etc.):


<P>

<PRE>
    There is also IMHO no requirement [for] MIME::Heads to look 
    like [email] headers; so to speak, the MIME::Head [simply stores] 
    the attributes of a complex object, e.g.:
</PRE>

<P>

<PRE>
        new MIME::Head type =&gt; &quot;text/plain&quot;,
                       charset =&gt; ...,
                       disposition =&gt; ..., ... ;
</PRE>

<P>

I agree in principle, but (alas and dammit) RFC-1521 says otherwise.
RFC-1521 [MIME] headers are a syntactic subset of RFC-822 [email] headers.
Perhaps a better name for these modules would be RFC1521:: instead of
MIME::, but we're a little beyond that stage now.


<P>

However, in my mind's eye, I see an abstract class, call it <A
HREF="Attrs.html">MIME::Attrs,</A> which does what Achim suggests... so you
could say:


<P>

<PRE>
     my $attrs = new MIME::Attrs type =&gt; &quot;text/plain&quot;,
				 charset =&gt; ...,
                                 disposition =&gt; ..., ... ;
</PRE>

<P>

We could even make it a superclass of <A HREF="Head.html">MIME::Head:</A>
that way, <A HREF="Head.html">MIME::Head</A> would have to implement its
interface, <EM>and</EM>
 allow itself to be initiallized from a <A HREF="Attrs.html">MIME::Attrs</A>
object.


<P>

<DT><STRONG><A NAME="item_to_subclass_or_not_to_subclass">To subclass or not to subclass?

</A></STRONG><DD>
When I originally wrote these modules for the CPAN, I agonized for a long
time about whether or not they really should subclass from <STRONG>Mail::Internet</STRONG>
 
(then at version 1.17). There were plusses:


<P>

<UL>
<LI><STRONG></STRONG>
Software reuse.


<P>

<LI><STRONG></STRONG>
Inheritance of the mail-sending utilities.


<P>

</UL>
And, unfortunately, minuses:


<P>

<UL>
<LI><STRONG></STRONG>
The Mail::Internet 1.17 model of messages as being short enough to fit into
in-core arrays is excellent for most email applications; however, it seemed
ill-suited for generic MIME applications, where MIME streams could be
megabytes long.


<P>

<LI><STRONG></STRONG>
The implementation of Mail::Internet 1.17 was excellent for certain kinds
of header manipulation, but the implementation of <CODE>get()</CODE> was less-efficient than I would have liked for MIME applications.


<P>

<LI><STRONG></STRONG>
In my heart of hearts, I honestly felt that the head should be encapsulated
as a first-class object, and in Mail::Internet 1.17 it was not.


<P>

</UL>
So I chose to make <A HREF="Head.html">MIME::Head</A> and <A
HREF="Entity.html">MIME::Entity</A> their own standalone modules.


<P>

Since that time, I worked with Graham Barr (author of most of the MailTools
package, and a darn nice guy to ``work'' with over email), and he has
graciously evolved the MailTools modules into a direction that addressed a
lot of these issues.


<P>

When MailTools hit its 1.06 release, it was finally time to finish what I
had started, and release MIME-tools 2.0. We now are almost at the stage of
a fully-integrated Mail/MIME environment.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="questionable_practices">Questionable practices</A></H3>
<DL>
<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_on_i">Fuzzing of CRLF and newline on input

</A></STRONG><DD>
RFC-1521 dictates that MIME streams have lines terminated by CRLF (<CODE>"\r\n"</CODE>). However, it is extremely likely that folks will want to parse MIME
streams where each line ends in the local newline character <CODE>"\n"</CODE> instead. 


<P>

An attempt has been made to allow the parser to handle both CRLF and
newline-terminated input.  


<P>

<STRONG>See <A HREF="ParserBase.html">MIME::ParserBase</A> for details.</STRONG>





<P>

<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_when">Fuzzing of CRLF and newline when decoding

</A></STRONG><DD>
The <CODE>"7bit"</CODE> and <CODE>"8bit"</CODE> decoders will decode both a <CODE>"\n"</CODE> and a <CODE>"\r\n"</CODE> end-of-line sequence into a <CODE>"\n"</CODE>.


<P>

The <CODE>"binary"</CODE> decoder (default if no encoding specified) still outputs stuff verbatim...
so a MIME message with CRLFs and no explicit encoding will be output as a
text file that, on many systems, will have an annoying ^M at the end of
each line... <EM>but this is as it should be</EM>
.


<P>

<STRONG>See <A HREF="ParserBase.html">MIME::ParserBase</A> for details.</STRONG>





<P>

<DT><STRONG><A NAME="item_fuzzing_of_crlf_and_newline_when">Fuzzing of CRLF and newline when encoding/composing

</A></STRONG><DD>
All encoders currently output the end-of-line sequence as a <CODE>"\n"</CODE>, with the assumption that the local mail agent will perform the conversion
from newline to CRLF when sending the mail.


<P>

However, there probably should be an option to output CRLF as per RFC-1521.
I'm currently working on a good mechanism for this.


<P>

<STRONG>See <A HREF="ParserBase.html">MIME::ParserBase</A> for details.</STRONG>





<P>

<DT><STRONG><A NAME="item_inability_to_handle_multipart_bo">Inability to handle multipart boundaries with embedded newlines

</A></STRONG><DD>
First, let's get something straight: this is an evil, EVIL practice. If
your mailer creates multipart boundary strings that contain newlines, give
it two weeks notice and find another one. If your mail robot receives MIME
mail like this, regard it as syntactically incorrect, which it is.


<P>

<STRONG>See <A HREF="ParserBase.html">MIME::ParserBase</A> for details.</STRONG>





<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="change_log">CHANGE LOG</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="current_events">Current events</A></H3>
<DL>
<DT><STRONG><A NAME="item_version_213">Version 2.13

</A></STRONG><DD>
<DL>
<DT><STRONG><A NAME="item_new_features">New features

</A></STRONG><DD>
<STRONG>Added RFC-1522-style decoding of encoded header fields.</STRONG>

Header decoding can now be done automatically during parsing via the new <CODE>decode()</CODE> method in <A HREF="Head.html">MIME::Head...</A> just tell your parser
object that you want to <CODE>decode_headers()</CODE>. 
<EM>Thanks to Kent Boortz for providing the idea, and the baseline
RFC-1522-decoding code!</EM>





<P>

<STRONG>Building MIME messages is even easier.</STRONG>
  Now, when you use <A HREF="Entity.html">MIME::Entity's</A> <CODE>build()</CODE> or <CODE>attach()</CODE>, you can also supply individual mail headers to set (e.g., <CODE>-Subject</CODE>, <CODE>-From</CODE>, <CODE>-To</CODE>).


<P>

Added <CODE>Disposition</CODE> to <A HREF="Entity.html">MIME::Entity's</A> <CODE>build()</CODE> method.
<EM>Thanks to Kurt Freytag for suggesting this feature.</EM>





<P>

An <CODE>X-Mailer</CODE> header is now output by default in all MIME-Entity-prepared messages, so
any bad MIME we generate can be traced back to this toolkit.


<P>

Added <CODE>purge()</CODE> method to <A HREF="Entity.html">MIME::Entity</A> for deleteing leftover
files.
<EM>Thanks to Jason L. Tibbitts III for suggesting this feature.</EM>





<P>

Added <CODE>seek()</CODE> and <CODE>tell()</CODE> methods to built-in <A HREF="IO.html">MIME::IO</A> classes. Only guaranteed
to work when reading!
<EM>Thanks to Jason L. Tibbitts III for suggesting this feature.</EM>





<P>

When parsing a multipart message with apparently no boundaries, the error
message you get has been improved.  
<EM>Thanks to Andreas Koenig for suggesting this.</EM>





<P>

<DT><STRONG><A NAME="item_bug_fixes">Bug fixes

</A></STRONG><DD>
<STRONG>Patched over a Perl 5.002 (and maybe earlier and later) bug involving
FileHandle::new_tmpfile.</STRONG>
  It seems that the underlying filehandles were not being closed when the
FileHandle objects went out of scope! There is now an internal routine that
creates true FileHandle objects for anonymous temp files. 
<EM>Thanks to Dragomir R. Radev and Zyx for reporting the weird behavior that
led to the discovery of this bug.</EM>





<P>

<A HREF="Entity.html">MIME::Entity's</A> <CODE>build()</CODE> method now warns you if you give it an illegal boundary string, and
substitutes one of its own.


<P>

<A HREF="Entity.html">MIME::Entity's</A> <CODE>build()</CODE> method now generates safer, fully-RFC-1521-compliant boundary strings.


<P>

Bug in <A HREF="Decoder.html">MIME::Decoder's</A> <CODE>install()</CODE> method was fixed.  
<EM>Thanks to Rolf Nelson and Nickolay Saukh for finding this.</EM>





<P>

Changed FileHandle::new_tmpfile to FileHandle->new_tmpfile, so some Perl
installations will be happier.  
<EM>Thanks to Larry W. Virden for finding this bug.</EM>





<P>

Gave <CODE>=over</CODE> an arg of 4 in all PODs.
<EM>Thanks to Larry W. Virden for pointing out the problems of bare =over's</EM>





<P>

</DL>
<DT><STRONG><A NAME="item_version_204">Version 2.04

</A></STRONG><DD>
<STRONG>A bug in <A HREF="Entity.html">MIME::Entity's</A> output method was
corrected.</STRONG>

<A HREF="Entity.html">MIME::Entity::print</A> now outputs everything to the
desired filehandle explicitly.  
<EM>Thanks to Jake Morrison for pointing out the incompatibility with
Mail::Header.</EM>





<P>

<DT><STRONG><A NAME="item_version_203">Version 2.03

</A></STRONG><DD>
<STRONG>Fixed bug in autogenerated filenames</STRONG>
 resulting from transposed ``if'' statement in <A
HREF="Parser.html">MIME::Parser,</A> removing spurious printing of header
as well. (Annoyingly, this bug is invisible if debugging is turned on!)
<EM>Thanks to Andreas Koenig for bringing this to my attention.</EM>





<P>

Fixed bug in <A HREF="Entity.html">MIME::Entity::body()</A> where it was
using the bodyhandle completely incorrectly.  
<EM>Thanks to Joel Noble for bringing this to my attention.</EM>





<P>

Fixed <A HREF="Head.html">MIME::Head::VERSION</A> so CPAN:: is happier.
<EM>Thanks to Larry Virden for bringing this to my attention.</EM>





<P>

Fixed undefined-variable warnings when dumping skeleton (happened when
there was no Subject: line)
<EM>Thanks to Joel Noble for bringing this to my attention.</EM>





<P>

<DT><STRONG><A NAME="item_version_202">Version 2.02

</A></STRONG><DD>
<STRONG>Stupid, stupid bugs in both BASE64 encoding and decoding were fixed.</STRONG>


<EM>Thanks to Phil Abercrombie for locating them.</EM>





<P>

<DT><STRONG><A NAME="item_version_201">Version 2.01

</A></STRONG><DD>
<STRONG>Modules now inherit from the new Mail:: modules!</STRONG>

This means big changes in behavior.


<P>

<STRONG><A HREF="Parser.html">MIME::Parser</A> can now store message data in-core.</STRONG>

There were a <EM>lot</EM>
 of requests for this feature.


<P>

<STRONG><A HREF="Entity.html">MIME::Entity</A> can now compose messages.</STRONG>

There were a <EM>lot</EM>
 of requests for this feature.


<P>

Added option to parse <CODE>"message/rfc822"</CODE> as a pseduo-multipart document.
<EM>Thanks to Andreas Koenig for suggesting this.</EM>





<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="ancient_history">Ancient history</A></H3>
<DL>
<DT><STRONG><A NAME="item_version_113">Version 1.13 	

</A></STRONG><DD>
<A HREF="Head.html">MIME::Head</A> now no longer requires space after
``:'', although either a space or a tab after the ``:'' will be swallowed
if there.  
<EM>Thanks to Igor Starovoitov for pointing out this shortcoming.</EM>





<P>

<DT><STRONG><A NAME="item_version_112">Version 1.12	

</A></STRONG><DD>
Fixed bugs in parser where CRLF-terminated lines were blowing out the
handling of preambles/epilogues.
<EM>Thanks to Russell Sutherland for reporting this bug.</EM>





<P>

Fixed idiotic <CODE>is_multipart()</CODE> bug.  
<EM>Thanks to Andreas Koenig for noticing it.</EM>





<P>

Added untested <CODE>binmode()</CODE> calls to parser for DOS, etc.
systems. No idea if this will work...


<P>

Reorganized the <CODE>output_path()</CODE> methods to allow easy use of
inheritance, as per Achim Bohnet's suggestion.


<P>

Changed <A HREF="Head.html">MIME::Head</A> to report mime_type more
accurately.


<P>

POSIX module no longer loaded by Parser if perl >= 5.002. Hey, 5.001'ers:
let me know if this breaks stuff, okay?


<P>

Added unsupported ./examples directory.


<P>

<DT><STRONG><A NAME="item_version_111">Version 1.11	

</A></STRONG><DD>
Converted over to using Makefile.PL.  
<EM>Thanks to Andreas Koenig for the much-needed kick in the pants...</EM>





<P>

Added t/*.t files for testing. Eeeeeeeeeeeh...it's a start.


<P>

Fixed bug in default parsing routine for generating output paths; it was
warning about evil filenames if there simply <EM>were</EM>
 no recommended filenames. D'oh!


<P>

Fixed redefined <CODE>parts()</CODE> method in Entity.


<P>

Fixed bugs in Head where field name wasn't being case folded.


<P>

<DT><STRONG><A NAME="item_version_110">Version 1.10	

</A></STRONG><DD>
A typo was causing the epilogue of an inner multipart message to be
swallowed to the end of the OUTER multipart message; this has now been
fixed.  
<EM>Thanks to Igor Starovoitov for reporting this bug.</EM>





<P>

A bad regexp for parameter names was causing some parameters to be parsed
incorrectly; this has also been fixed.  
<EM>Thanks again to Igor Starovoitov for reporting this bug.</EM>

	
It is now possible to get full control of the filenaming algorithm before
output files are generated, and the default algorithm is safer.  
<EM>Thanks to Laurent Amon for pointing out the problems, and suggesting some
solutions.</EM>





<P>

Fixed illegal ``simple'' multipart test file. D'OH!


<P>

<DT><STRONG><A NAME="item_version_19">Version 1.9	

</A></STRONG><DD>
No changes: 1.8 failed CPAN registration


<P>

<DT><STRONG><A NAME="item_version_18">Version 1.8.	

</A></STRONG><DD>
Fixed incompatibility with 5.001 and FileHandle::new_tmpfile Added COPYING
file, and improved README.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="future_plans">Future plans</A></H3>
<UL>
<LI><STRONG></STRONG>
Dress up mimedump and mimeexplode utilities to take cmd line options for
directory, environment vars (MIMEDUMP_OUTPUT, etc.).


<P>

<LI><STRONG></STRONG>
Make it even easier to compose and send MIME messages.


<P>

<LI><STRONG></STRONG>
Make VERSIONs a bit more sensible (e.g., 2.8, 2.9, 2.10 effectively goes
backwards...).


<P>

</UL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="terms_and_conditions">TERMS AND CONDITIONS</A></H2>
Copyright (c) 1996 by Eryq. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself. 


<P>

See the COPYING file in the distribution for details.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="support">SUPPORT</A></H2>
Please email me directly with questions/problems (see AUTHOR below).


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR </A></H2>
<STRONG>MIME-tools was created by:</STRONG>





<P>

<PRE>
    ___  _ _ _   _  ___ _     
   / _ \| '_| | | |/ _ ' /    Eryq
  |  __/| | | |_| | |_| |     http://www.mcs.net/~eryq
   \___||_|  \__, |\__, |__   eryq@enteract.com
             |___/    |___/   eryq@rhine.gsfc.nasa.gov 
</PRE>

<P>

Initial release (1.0): 28 April 1996. Re-release (2.0): Halloween 1996.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="acknowledgments">ACKNOWLEDGMENTS</A></H2>
<STRONG>This kit would not have been possible</STRONG>
 but for the direct contributions of the following:


<P>

<PRE>
    Gisle Aas          The MIME encoding/decoding modules
    Laurent Amon       Bug reports and suggestions
    Graham Barr        The new MailTools
    Achim Bohnet       Numerous good suggestions, including the I/O model
    Kent Boortz        Initial code for RFC-1522-decoding of MIME headers
    Andreas Koenig     Numerous good ideas, tons of beta testing,
                       and help with CPAN-friendly packaging
    Igor Starovoitov   Bug reports and suggestions
 
Not to mention the Accidental Beta Test Team, whose bug reports (and
comments) have been invaluable in improving the whole:
</PRE>

<P>

<PRE>
    Phil Abercrombie
    Kurt Freytag
    Jake Morrison
    Rolf Nelson
    Joel Noble    
    Andrew Pimlott
    Dragomir R. Radev
    Nickolay Saukh
    Russell Sutherland
    Larry Virden
    Zyx
</PRE>

<P>

Please forgive me if I've accidentally left you out. Better yet, email me,
and I'll put you in.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="see_also">SEE ALSO</A></H2>
Users of this toolkit may wish to read the documentation of Mail::Header
and Mail::Internet.


<P>

The MIME format is documented in RFCs 1521-1522, and more recently in RFCs
2045-2049.


<P>

The MIME header format is an outgrowth of the mail header format documented
in RFC 822.


<P>

</BODY>
</HTML>
