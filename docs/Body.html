    <HTML>

    <HEAD>
    <TITLE>MIME::Body</TITLE>
    </HEAD>

<BODY  LINK="#C00000"    ALINK="#FF2020"  VLINK="#900000" >    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><A HREF="MIME-tools.html">Home</A></B></TD><TD WIDTH=20%><B><FONT SIZE=-1 COLOR=#000000>MIME::Body</FONT></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Decoder.html">MIME::Decoder</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Entity.html">MIME::Entity</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Head.html">MIME::Head</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ParserBase.html">MIME::ParserBase</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#400000>MIME::<BR>Body</FONT></B></H1>
	    <img src="mime-sm.gif" alt="LOGO">
	    <P><FONT SIZE=+1 COLOR=#400000><I>It's MIME time!</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#defining_your_own_subclasses">DEFINING YOUR OWN SUBCLASSES</A>
	<UL>
		<LI><A HREF="#writing_a_body_class">Writing a "body" class</A>
		<LI><A HREF="#writingusing_an_io_handle_class">Writing/using an "I/O handle" class</A>
		</UL>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#design_issues">Design issues</A>
		</UL>
	<LI><A HREF="#subclasses">SUBCLASSES</A>
	<UL>
		<LI><A HREF="#mimebodyfile">MIME::Body::File;</A>
		<LI><A HREF="#mimebodyscalar">MIME::Body::Scalar;</A>
		</UL>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#version">VERSION</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
<A HREF="Body.html">MIME::Body</A> - the body of a MIME message


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
Here's how a typical body object is created and used:


<P>

<PRE>
   # Create new body:
   $body = new MIME::Body::File &quot;/path/to/file&quot;;
   
   # Write data to the body:
   $IO = $body-&gt;open(&quot;w&quot;)      || die &quot;open body: $!&quot;;
   $IO-&gt;print($message);
   $IO-&gt;close                  || die &quot;close I/O handle: $!&quot;;
   
   # Read data from the body:
   $IO = $body-&gt;open(&quot;r&quot;)      || die &quot;open body: $!&quot;;
   while (defined($_ = $IO-&gt;getline)) {
       # do stuff
   }
   $IO-&gt;close                  || die &quot;close I/O handle: $!&quot;;
</PRE>

<P>

For example, this subclass stores the data in a disk file, which is only
opened when needed:


<P>

<PRE>
   $body = new MIME::Body::File &quot;/path/to/file&quot;;
</PRE>

<P>

While <EM>this</EM>
 subclass stores the data in an in-core scalar:


<P>

<PRE>
   $body = new MIME::Body::Scalar \$scalar;
</PRE>

<P>

In any case, once a <A HREF="Body.html">MIME::Body</A> has been created,
you use the same mechanisms for reading from or writing to it, no matter
what the subclass is.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
MIME messages can be very long (e.g., tar files, MPEGs, etc.) or very short
(short textual notes, as in ordinary mail). Long messages are best stored
in files, while short ones are perhaps best stored in core.


<P>

This class is an attempt to define a common interface for objects which
contain message data, regardless of how the data is physically stored.
Here's an overview:  


<P>

<PRE>
            head()        .--------.
            returns a...  | MIME:: |
            .------------&gt;| Head   |
     .--------.           `--------'
     | MIME:: |
     | Entity |           .--------. 
     `--------'           | MIME:: | 
            `------------&gt;| Body   |           .--------. read()
             bodyhandle() `--------'           | MIME:: | getline()
             returns a...        `------------&gt;| IO     | print()
                                  open()       `--------' etc...
                                  returns a...
</PRE>

<P>

It works this way:


<P>

<UL>
<LI><STRONG></STRONG>
<STRONG>An ``entity'' has a ``head'' and a ``body''.</STRONG>
  
Entities are MIME message parts.


<P>

<LI><STRONG></STRONG>
<STRONG>A ``body'' knows where the data is.</STRONG>
  
You can ask to ``open'' this data source for <EM>reading</EM>
 or <EM>writing</EM>
, and you will get back an ``I/O handle''.


<P>

<LI><STRONG></STRONG>
<STRONG>An ``I/O handle'' knows how to read/write the data.</STRONG>

It is an object that is basically like an IO::Handle or a FileHandle... it
can be any class, so long as it supports a small, standard set of methods
for reading from or writing to the underlying data source.


<P>

</UL>
The lifespan of a ``body'' usually looks like this:


<P>

<OL>
<LI><STRONG><A NAME="item_">



</A></STRONG>
Body object is created by a <A HREF="Parser.html">MIME::Parser</A> during
parsing. It's at this point that the actual <A
HREF="Body.html">MIME::Body</A> subclass is chosen, and <CODE>new()</CODE>
is invoked. (For example: if the body data is going to a file, then it is
at this point that the class <A HREF="Body.html">MIME::Body::File,</A> and
the filename, is chosen).


<P>

<LI><STRONG><A NAME="item_">



</A></STRONG>
Data is written (usually by the MIME parser) like this:


<P>

a. Body is opened for writing, via <CODE>open("w")</CODE>. This will trash any previous contents, and return an ``I/O handle''
opened for writing.


<P>

b. Data is written to the I/O handle, via <CODE>print().</CODE>


<P>

c. I/O handle is closed, via <CODE>close().</CODE>


<P>

<LI><STRONG><A NAME="item_"> 

 

</A></STRONG>
Data is read (usually by the user application) like this: 


<P>

a. Body is opened for reading by a user application, via <CODE>open("r")</CODE>. This will return an ``I/O handle'' opened for reading.


<P>

b. Data is read from the I/O handle, via <CODE>read(),</CODE>
<CODE>getline(),</CODE> or <CODE>getlines().</CODE>


<P>

c. I/O handle is closed, via <CODE>close().</CODE>


<P>

<LI><STRONG><A NAME="item_"> 

 

</A></STRONG>
Body object is destructed.


<P>

</OL>
You can write your own subclasses, as long as they follow the interface
described below. Implementers of subclasses should assume that steps 2 and
3 may be repeated any number of times, and in different orders (e.g.,
1-2-2-3-2-3-3-3-3-3-2-4).


<P>

Users should be aware that unless they know for certain what they have,
they should not assume that the body has an underlying filehandle.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="defining_your_own_subclasses">DEFINING YOUR OWN SUBCLASSES</A></H2>
So you're not happy with files and scalars? No problem: just define your
own <A HREF="Body.html">MIME::Body</A> subclass, and make a subclass of <A
HREF="Parser.html">MIME::Parser</A> or <A
HREF="ParserBase.html">MIME::ParserBase</A> which returns an instance of
your body class whenever appropriate in the <CODE>new_body_for(head)</CODE> method.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="writing_a_body_class">Writing a "body" class</A></H3>
Your ``body'' class must inherit from <A HREF="Body.html">MIME::Body</A>
(or some subclass of it), and it must either provide or inherit the
following methods:


<P>

<DL>
<DT><STRONG><A NAME="item_init_args">init ARGS...

</A></STRONG><DD>
<EM>Instance method.</EM>

This is called automatically by <CODE>new()</CODE>, with the arguments given to <CODE>new()</CODE>. The arguments are optional, and entirely up to your class.


<P>

<DT><STRONG><A NAME="item_open_mode">open MODE

</A></STRONG><DD>
<EM>Instance method.</EM>

This should do whatever is necessary to open the body for either writing
(if MODE is ``w'') or reading (if mode is ``r''). Return an ``I/O handle''
on success, false on error.


<P>

<DT><STRONG><A NAME="item_binmode_onoff">binmode [ONOFF]

</A></STRONG><DD>
<EM>Instance method.</EM>

With argument, flags whether or not <CODE>open()</CODE> should return an
I/O handle which has <CODE>binmode()</CODE> activated. With no argument,
just returns the current value. The inherited action should be fine.


<P>

<DT><STRONG><A NAME="item_path">path

</A></STRONG><DD>
<EM>Instance method.</EM>

Oh, the joys of encapsulation. If you're storing the body data in a new
disk file, you'll want to give applications the ability to get at that
file, if only for cleanup (see <A
HREF="Entity.html">MIME::Entity::purge()</A> for an example). This method
should return the path to the file, or undef if there is none (e.g., if the
data is in core). The default inherited method just returns undef.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="writingusing_an_io_handle_class">Writing/using an "I/O handle" class</A></H3>
Your ``body'' class' <CODE>open()</CODE> method must return an ``I/O handle'' object, which can be any object that
supports a small set of standard methods for reading/writing data.  


<P>

See the documentation on the <STRONG><A HREF="IO.html">MIME::IO</A></STRONG>
 class for details on what is expected of an I/O handle.
<STRONG>Note that the IO::Handle class already conforms to this interface.</STRONG>





<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="design_issues">Design issues</A></H3>
One reason I didn't just use FileHandle or IO::Handle objects for message
bodies was that I wanted a ``body'' object to be a form of completely
encapsulated program-persistent storage; that is, I wanted users to be able
to write code like this...


<P>

<PRE>
   # Get body handle from this MIME message, and read its data:
   $body = $entity-&gt;bodyhandle;
   $IO = $body-&gt;open(&quot;r&quot;);
   while (defined($_ = $IO-&gt;getline)) {
       print STDOUT $_;
   }
   $IO-&gt;close;
</PRE>

<P>

...without requiring that they know anything more about how the
<CODE>$body</CODE> object is actually storing its data (disk file, scalar
variable, array variable, or whatever).


<P>

Storing the body of each MIME message in a persistently-open IO::Handle was
a possibility, but it seemed like a bad idea, considering that a single
multipart MIME message could easily suck up all the available file
descriptors on som OSes. This risk increases if the user application is
processing more than one MIME entity at a time.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="subclasses">SUBCLASSES</A></H2>
Basically, we have the following classes:


<P>

<PRE>
   Body                Stores body   When open()ed,     Someday soon
   class:              data in:      returns:           will return:
   ----------------------------------------------------------------------
   MIME::Body::File    disk file     MIME::IO::Handle   IO::Handle
   MIME::Body::Scalar  scalar        MIME::IO::Scalar   IO::????
</PRE>

<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="mimebodyfile">MIME::Body::File;</A></H3>
A body class that stores the data in a disk file. The I/O handle is a
wrapped filehandle. Invoke the constructor as:


<P>

<PRE>
    $body = new MIME::Body::File &quot;/path/to/file&quot;;
</PRE>

<P>

In this case, the <A HREF="#item_path">path</A> method would return the given path.


<P>

You can even use this class to pipe the data through shell commands on
input and/or output. For example, here's an easy way to store the data in
compressed format without having to explicitly do the compression yourself:


<P>

<PRE>
    $body = new MIME::Body::File &quot;/tmp/somefile.gz&quot;;
    $body-&gt;writer(&quot;| gzip &gt; /tmp/somefile.gz&quot;);
    $body-&gt;reader(&quot;zcat /tmp/somefile.gz |&quot;);
    ...
    $IO = $body-&gt;open(&quot;w&quot;)  || die &quot;open failed: $!&quot;;
    $IO-&gt;print(&quot;I'll automatically be stored compressed!\n&quot;);
    $IO-&gt;close              || die &quot;close failed: $!&quot;; 
</PRE>

<P>

Notice the semantics of the ``path'' in this case: it names the file that
is created to hold the data, even though that file can't be used directly.


<P>

<STRONG>Note:</STRONG>
 All of the usual caveats related to shell commands apply! To make sure you
won't accidentally do something you'll regret, use taint-checking (<STRONG>perl -T</STRONG>
) in your application.


<P>

<STRONG>Note:</STRONG>
 I would have had <A HREF="Body.html">MIME::Body::File</A> return a
FileHandle, except that there are some methods that FileHandle does not
support in 5.002, and it was too soon to require IO::Handle.


<P>

<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A NAME="mimebodyscalar">MIME::Body::Scalar;</A></H3>
A body class that stores the data in-core, in a simple scalar. Invoke the
constructor as:


<P>

<PRE>
    $body = new MIME::Body::Scalar \$scalar;
</PRE>

<P>

A single scalar argument sets the body to that value, exactly as though
you'd opened for the body for writing, written the value, and closed the
body again: <CODE>$body</CODE> = new <A
HREF="Body.html">MIME::Body::Scalar</A> ``Line 1\nLine 2\nLine 3'';


<P>

A single array reference sets the body to the result of joining all the
elements of that array together:


<P>

<PRE>
    $body = new MIME::Body::Scalar [&quot;Line 1\n&quot;,
                                    &quot;Line 2\n&quot;,
                                    &quot;Line 3&quot;];
</PRE>

<P>

Uses <STRONG><A HREF="IO.html">MIME::IO::Scalar</A></STRONG>
 as the I/O handle.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR</A></H2>
Copyright (c) 1996 by Eryq / <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A>  


<P>

All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


<P>

Thanks to Achim Bohnet for suggesting that <A
HREF="Parser.html">MIME::Parser</A> not be restricted to the use of
FileHandles.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="redbul.gif" ALT="*" BORDER=0></A> <A NAME="version">VERSION</A></H2>
$Revision: 1.11 $ $Date: 1997/01/13 00:21:47 $


<P>

</BODY>
</HTML>
