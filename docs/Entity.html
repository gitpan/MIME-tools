    <HTML>

    <HEAD>
    <TITLE>MIME::Entity</TITLE>
    </HEAD>

<BODY  LINK="#C00000"    ALINK="#FF2020"  VLINK="#900000" >    <A NAME="#__top"> <P></A>
<CENTER><TABLE BORDER=2 CELLPADDING=2 WIDTH=100%><TR><TD WIDTH=20% ROWSPAN=3 ALIGN=CENTER><B><A HREF="MIME-tools.html">Home</A></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Body.html">MIME::Body</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Decoder.html">MIME::Decoder</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1 COLOR=#000000>MIME::Entity</FONT></B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Head.html">MIME::Head</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="IO.html">MIME::IO</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Latin1.html">MIME::Latin1</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="Parser.html">MIME::Parser</A></FONT>
</B></TD><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ParserBase.html">MIME::ParserBase</A></FONT>
</B></TD><TR><TD WIDTH=20%><B><FONT SIZE=-1><A HREF="ToolUtils.html">MIME::ToolUtils</A></FONT>
</B></TD></TABLE></CENTER>    <P><TABLE BORDER=0>
      <TR>
	<TD VALIGN=TOP ALIGN=CENTER>
	    <H1><B><FONT SIZE=7 COLOR=#400000>MIME::<BR>Entity</FONT></B></H1>
	    <img src="mime-sm.gif" alt="LOGO">
	    <P><FONT SIZE=+1 COLOR=#400000><I>It's MIME time!</I></FONT>
        <TD VALIGN=TOP>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#synopsis">SYNOPSIS</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
	<UL>
		<LI><A HREF="#constructors_and_converters">Constructors and converters</A>
		<LI><A HREF="#instance_methods">Instance methods</A>
		</UL>
	<LI><A HREF="#notes">NOTES</A>
	<UL>
		<LI><A HREF="#under_the_hood">Under the hood</A>
		<LI><A HREF="#design_issues">Design issues</A>
		</UL>
	<LI><A HREF="#author">AUTHOR</A>
	<LI><A HREF="#version">VERSION</A>
</UL>
<!-- INDEX END -->

    </TABLE>
<HR>
<P>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="name">NAME</A></H2>
<A HREF="Entity.html">MIME::Entity</A> - class for parsed-and-decoded MIME
message


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="synopsis">SYNOPSIS</A></H2>
Create a MIME entity from an array, and output it as a MIME stream to
STDOUT:


<P>

<PRE>
    $ent = new MIME::Entity [
			  &quot;Subject: Greetings\n&quot;,
			  &quot;Content-type: text/plain\n&quot;,
			  &quot;Content-transfer-encoding: 7bit\n&quot;,
			  &quot;\n&quot;,
			  &quot;Hi there!\n&quot;, 
			  &quot;Bye there!\n&quot;
        		  ];
    $ent-&gt;print(\*STDOUT);
</PRE>

<P>

Create a document for an ordinary 7-bit ASCII text file (lots of stuff is
defaulted for us):


<P>

<PRE>
    $ent = build MIME::Entity Path=&gt;&quot;english-msg.txt&quot;;
</PRE>

<P>

Create a document for a text file with 8-bit (Latin-1) characters:


<P>

<PRE>
    $ent = build MIME::Entity Path     =&gt;&quot;french-msg.txt&quot;,
                              Encoding =&gt;&quot;quoted-printable&quot;,
                              -From    =&gt;'jean.luc@inria.fr',
                              -Subject =&gt;&quot;C'est bon!&quot;;
</PRE>

<P>

Create a document for a GIF file (the description is completely optional,
and note that we have to specify content-type and encoding since they're
not the default values):


<P>

<PRE>
    $ent = build MIME::Entity Description =&gt; &quot;A pretty picture&quot;,
                              Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                              Type        =&gt; &quot;image/gif&quot;,
                              Encoding    =&gt; &quot;base64&quot;;
</PRE>

<P>

Create a document that you already have the text for:


<P>

<PRE>
    $ent = build MIME::Entity  Type        =&gt; &quot;text/plain&quot;,
                               Encoding    =&gt; &quot;quoted-printable&quot;,
                               Data        =&gt; [
                                     &quot;First line.\n&quot;,
                                     &quot;Second line.\n&quot;,
                                     &quot;Last line.\n&quot;,
                               ];
</PRE>

<P>

Create a multipart message (could it <EM>be</EM>
 much easier?)


<P>

<PRE>
    # Create the top-level, and set up the mail headers:
    $top = build MIME::Entity Type     =&gt; &quot;multipart/mixed&quot;,
                              -From    =&gt; 'me@myhost.com',
                              -To      =&gt; 'you@yourhost.com',
                              -Subject =&gt; &quot;Hello, nurse!&quot;;
    
    # Attachment #1: a simple text document: 
    attach $top  Path=&gt;&quot;./testin/short.txt&quot;;
    
    # Attachment #2: a GIF file:
    attach $top  Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                 Type        =&gt; &quot;image/gif&quot;,
                 Encoding    =&gt; &quot;base64&quot;;
     
    # Attachment #3: text we'll create with text we have on-hand:
    attach $top Data=&gt;$contents;
    
    # Output!
    $top-&gt;print(\*STDOUT);
</PRE>

<P>

Muck about with the signature:


<P>

<PRE>
    # Sign it (atomatically removes any existing signature):
    $top-&gt;sign(File=&gt;&quot;$ENV{HOME}/.signature&quot;);
        
    # Remove any signature within 15 lines of the end:
    $top-&gt;remove_sig(15);
</PRE>

<P>

Extract information from MIME entities:


<P>

<PRE>
    # Get the head, a MIME::Head:
    $head = $ent-&gt;head;
    
    # Get the body, as a MIME::Body;
    $bodyh = $ent-&gt;bodyhandle;
</PRE>

<P>

If you want a <CODE>Content-type:</CODE> header to be output <EM>and output correctly</EM>

for the current body <CODE>part(s),</CODE> here's how to do it:


<P>

<PRE>
    # Compute content-lengths for singleparts based on bodies:
    $entity-&gt;sync_headers(Length=&gt;'COMPUTE');
    
    # Output!
    $entity-&gt;print(\*STDOUT);
</PRE>

<P>

See <A HREF="Parser.html">MIME::Parser</A> for additional examples of
usage.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="description">DESCRIPTION</A></H2>
A subclass of <STRONG>Mail::Internet</STRONG>
.


<P>

This package provides a class for representing MIME message entities, as
specified in RFC 1521, <EM>Multipurpose Internet Mail Extensions</EM>
.


<P>

Here are some excerpts from RFC-1521 explaining the terminology: each is
accompanied by the equivalent in MIME:: terms:


<P>

<DL>
<DT><STRONG><A NAME="item_message">Message

</A></STRONG><DD>
From RFC-1521:


<P>

<PRE>
    The term &quot;message&quot;, when not further qualified, means either the
    (complete or &quot;top-level&quot;) message being transferred on a network, or
    a message encapsulated in a body of type &quot;message&quot;.
</PRE>

<P>

There currently is no explicit package for messages; under MIME::, messages
may be read in from readable files or filehandles. A future extension will
allow them to be read from any object reference that responds to a special
``next line'' method.


<P>

<DT><STRONG><A NAME="item_body_part">Body part

</A></STRONG><DD>
From RFC-1521:


<P>

<PRE>
    The term &quot;body part&quot;, in this document, means one of the parts of the
    body of a multipart entity. A body part has a header and a body, so
    it makes sense to speak about the body of a body part.
</PRE>

<P>

Since a body part is just a kind of entity (see below), a body part is
represented by an instance of <A HREF="Entity.html">MIME::Entity.</A>


<P>

<DT><STRONG><A NAME="item_entity">Entity

</A></STRONG><DD>
From RFC-1521:


<P>

<PRE>
    The term &quot;entity&quot;, in this document, means either a message or a body
    part.  All kinds of entities share the property that they have a
    header and a body.
</PRE>

<P>

An entity is represented by an instance of <A
HREF="Entity.html">MIME::Entity.</A> There are instance methods for
recovering the header (a <A HREF="Head.html">MIME::Head)</A> and the body
(see below).


<P>

<DT><STRONG><A NAME="item_body">Body

</A></STRONG><DD>
From RFC-1521:


<P>

<PRE>
    The term &quot;body&quot;, when not further qualified, means the body of an
    entity, that is the body of either a message or of a body part.
</PRE>

<P>

Well, this is a toughie. Both Mail::Internet (1.17) and Mail::MIME (1.03)
represent message bodies in-core; unfortunately, this is not always the
best way to handle things, especially for MIME streams that contain
multi-megabyte tar files.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="public_interface">PUBLIC INTERFACE</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="constructors_and_converters">Constructors and converters</A></H3>
<DL>
<DT><STRONG><A NAME="item_new_source">new [SOURCE]

</A></STRONG><DD>
<EM>Class method.</EM>

Create a new, empty MIME entity. Basically, this uses the Mail::Internet
constructor...


<P>

If SOURCE is an ARRAYREF, it is assumed to be an array of lines that will
be used to create both the header and an in-core body.


<P>

Else, if SOURCE is defined, it is assumed to be a filehandle from which the
header and in-core body is to be read. 


<P>

<STRONG>Note:</STRONG>
 in either case, the body will not be <EM>parsed:</EM>
 merely read!


<P>

<DT><STRONG><A NAME="item_build_paramhash">build PARAMHASH

</A></STRONG><DD>
<EM>Class/instance method.</EM>

A quick-and-easy catch-all way to create an entity. Use it like this to
build a ``normal'' single-part entity:


<P>

<PRE>
   $ent = build MIME::Entity Type     =&gt; &quot;image/gif&quot;,
		             Encoding =&gt; &quot;base64&quot;,
                             Path     =&gt; &quot;/path/to/xyz12345.gif&quot;,
                             Filename =&gt; &quot;saveme.gif&quot;,
                             Disposition =&gt; &quot;attachment&quot;;
</PRE>

<P>

And like this to build a ``multipart'' entity:


<P>

<PRE>
   $ent = build MIME::Entity Type     =&gt; &quot;multipart/mixed&quot;,
                             Boundary =&gt; &quot;---1234567&quot;;
</PRE>

<P>

A minimal MIME header will be created. If you want to add or modify any
header fields afterwards, you can of course do so via the underlying head
object... but hey, there's now a prettier syntax!


<P>

<PRE>
   $ent = build MIME::Entity Type     =&gt;&quot;multipart/mixed&quot;,
                             -From         =&gt; $myaddr,
                             -Subject      =&gt; &quot;Hi!&quot;,
                            '-X-Certified' =&gt; ['SINED','SEELED','DELIVERED'];
</PRE>

<P>

Normally, an <CODE>X-Mailer</CODE> header field is output which contains this toolkit's name and version (plus
this module's RCS version). This will allow any bad MIME we generate to be
traced back to us. You can of course overwrite that header with your own:


<P>

<PRE>
   $ent = build MIME::Entity  Type       =&gt; &quot;multipart/mixed&quot;,
                             '-X-Mailer' =&gt; &quot;myprog 1.1&quot;;
</PRE>

<P>

Or remove it entirely:


<P>

<PRE>
   $ent = build MIME::Entity  Type       =&gt; &quot;multipart/mixed&quot;,
                             '-X-Mailer' =&gt; undef;
</PRE>

<P>

OK, enough hype. The parameters are:


<P>

<DL>
<DT><STRONG><A NAME="item_fieldname">-FIELDNAME

</A></STRONG><DD>
Any parameter with a leading <CODE>'-'</CODE> is taken to be a mail header field, whose value is to <EM>replace</EM>
 the corresponding header field <EM>after</EM>
 we go through all the other params and construct the basic MIME header. Use
with care: you don't want to trash those nice MIME fields!
<EM>Syntactic sugar, totally optional. TMTOWTDI.</EM>





<P>

<DT><STRONG><A NAME="item_boundary">Boundary

</A></STRONG><DD>
<EM>Multipart entities only. Optional.</EM>
  
The boundary string. As per RFC-1521, it must consist only of the
characters <CODE>[0-9a-zA-Z'()+_,-./:=?]</CODE> and space (you'll be warned, and your boundary will be ignored, if this is
not the case). If you omit this, a random string will be chosen... which is
probably safer.


<P>

<DT><STRONG><A NAME="item_data">Data

</A></STRONG><DD>
<EM>Single-part entities only. Optional.</EM>
  
An alternative to Path (q.v.): the actual data, either as a scalar or an
array reference (whose elements are joined together to make the actual
scalar). The body is opened on the data using <A
HREF="Body.html">MIME::Body::Scalar.</A>


<P>

<DT><STRONG><A NAME="item_description">Description

</A></STRONG><DD>
<EM>Optional.</EM>
  
The text of the content-description. If you don't specify it, the field is
not put in the header.


<P>

<DT><STRONG><A NAME="item_disposition">Disposition

</A></STRONG><DD>
<EM>Optional.</EM>
  
The basic content-disposition (<CODE>"attachment"</CODE> or <CODE>"inline"</CODE>). If you don't specify it, it defaults to ``inline'' for backwards
compatibility.  <EM>Thanks to Kurt Freytag for suggesting this feature.</EM>





<P>

<DT><STRONG><A NAME="item_encoding">Encoding

</A></STRONG><DD>
<EM>Optional.</EM>
  
The content-transfer-encoding. If you don't specify it, the field is not
put in the header... which means that the encoding implicitly defaults to <CODE>"7bit"</CODE> as per RFC-1521.  <EM>Do yourself a favor: put it in.</EM>





<P>

<DT><STRONG><A NAME="item_filename">Filename

</A></STRONG><DD>
<EM>Single-part entities only. Optional.</EM>
  
The recommended filename. Overrides any name extracted from <A HREF="#item_path">Path</A>. The information is stored both the deprecated (content-type) and
preferred (content-disposition) locations.


<P>

<DT><STRONG><A NAME="item_path">Path

</A></STRONG><DD>
<EM>Single-part entities only. Optional.</EM>
  
The path to the file to attach. The body is opened on that file using <A
HREF="Body.html">MIME::Body::File.</A>


<P>

<DT><STRONG><A NAME="item_top">Top

</A></STRONG><DD>
<EM>Optional.</EM>
  
Is this a top-level entity? If so, it must sport a MIME-Version. The
default is true. (NB: look at how <CODE>attach()</CODE> uses it.)


<P>

<DT><STRONG><A NAME="item_type">Type

</A></STRONG><DD>
<EM>Optional.</EM>
  
The basic content-type (<CODE>"text/plain"</CODE>, etc.). If you don't specify it, it defaults to <CODE>"text/plain"</CODE> 
as per RFC-1521.  <EM>Do yourself a favor: put it in.</EM>





<P>

</DL>
</DL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="instance_methods">Instance methods</A></H3>
<DL>
<DT><STRONG><A NAME="item_add_part_entity">add_part ENTITY

</A></STRONG><DD>
<EM>Instance method.</EM>

Assuming we are a multipart message, add a body part (a <A
HREF="Entity.html">MIME::Entity)</A> to the array of body parts. Do <STRONG>not</STRONG>
 call this for single-part messages; i.e., don't call it unless the header
has a <CODE>"multipart"</CODE> content-type.


<P>

Returns the part that was just added.


<P>

<DT><STRONG><A NAME="item_attach_paramhash">attach PARAMHASH

</A></STRONG><DD>
<EM>Instance method.</EM>

The real quick-and-easy way to create multipart messages. Basically
equivalent to:


<P>

<PRE>
    $entity-&gt;add_part(ref($entity)-&gt;build(PARAMHASH, Top=&gt;0));
</PRE>

<P>

Except that it's a lot nicer to look at.


<P>

<DT><STRONG><A NAME="item_body_value">body [VALUE]

</A></STRONG><DD>
<EM>Instance method.</EM>





<P>

<DL>
<DT><STRONG><A NAME="item_if_emulating_version_1x">If emulating version 1.x:

</A></STRONG><DD>
Get or set the path to the file containing the body.


<P>

If <CODE>VALUE</CODE>  <EM>is not</EM>
 given, the current body file is returned. If <CODE>VALUE</CODE>  <EM>is</EM>
 given, the body file is set to the new value, and the previous value is
returned.


<P>

<DT><STRONG><A NAME="item_otherwise">Otherwise:

</A></STRONG><DD>
Get or set the body, as an array of lines. This should be regarded as a
read-only data structure: changing its contents will have unpredictable
results (you can, of course, make your own copy, and work with that).  


<P>

Provided for compatibility with Mail::Internet, and it might not be as
efficient as you'd like. Also, it's somewhat silly/wrongheaded for binary
bodies, like GIFs and tar files.


<P>

</DL>
Both forms are deprecated for MIME entities: instead, use the
<CODE>bodyhandle()</CODE> method to get and use a <A
HREF="Body.html">MIME::Body.</A> The content-type of the entity will tell
you whether that body is best read as text (via <CODE>getline())</CODE> or
raw data (via <CODE>read()).</CODE>


<P>

<DT><STRONG><A NAME="item_bodyhandle_value">bodyhandle [VALUE]

</A></STRONG><DD>
<EM>Instance method.</EM>

Get or set an abstract object representing the body.


<P>

If <CODE>VALUE</CODE>  <EM>is not</EM>
 given, the current bodyhandle is returned. If <CODE>VALUE</CODE>  <EM>is</EM>
 given, the bodyhandle is set to the new value, and the previous value is
returned.


<P>

<DT><STRONG><A NAME="item_dump_skeleton_filehandle">dump_skeleton [FILEHANDLE]

</A></STRONG><DD>
<EM>Instance method.</EM>

Dump the skeleton of the entity to the given FILEHANDLE, or to the
currently-selected one if none given. This is really just useful for
debugging purposes.


<P>

<DT><STRONG><A NAME="item_head_value">head [VALUE]

</A></STRONG><DD>
<EM>Instance method.</EM>

Get/set the head. 


<P>

If there is no VALUE given, returns the current head. If none exists, an
empty instance of <A HREF="Head.html">MIME::Head</A> is created, set, and
returned.


<P>

<STRONG>Note:</STRONG>
 This is a patch over a bug in Mail::Internet, which doesn't provide a
method for setting the head to some given object.


<P>

<DT><STRONG><A NAME="item_is_multipart">is_multipart

</A></STRONG><DD>
<EM>Instance method.</EM>

Does this entity's MIME type indicate that it's a multipart entity? Returns
undef (false) if the answer couldn't be determined, 0 (false) if it was
determined to be false, and true otherwise.


<P>

Note that this says nothing about whether or not parts were extracted.


<P>

<DT><STRONG><A NAME="item_mime_type">mime_type

</A></STRONG><DD>
<EM>Instance method.</EM>

A purely-for-convenience method. This simply relays the request to the
associated <A HREF="Head.html">MIME::Head</A> object. The following are
identical:


<P>

<PRE>
    $x = $entity-&gt;mime_type;
    
    $x = $entity-&gt;head-&gt;mime_type;
</PRE>

<P>

If there is no head, returns undef in a scalar context and the empty array
in a list context.


<P>

Note that, while parsed entities still have MIME types, they do not have
MIME encodings, or MIME versions, or fields, etc., etc... for those
attributes, you still have to go to the <EM>head</EM>
 explicitly.


<P>

<DT><STRONG><A NAME="item_parts">parts

</A></STRONG><DD>
<EM>Instance method.</EM>

Return an array of all sub parts (each of which is a <A
HREF="Entity.html">MIME::Entity),</A> or the empty array if there are none.


<P>

For single-part messages, the empty array will be returned. For multipart
messages, the preamble and epilogue parts are <EM>not</EM>
 in the list!


<P>

Note that in a scalar context, this returns you the number of parts.


<P>

<DT><STRONG><A NAME="item_print_filehandle_options">print [FILEHANDLE], [OPTIONS]

</A></STRONG><DD>
<EM>Instance method, override.</EM>

Print the entity to the given FILEHANDLE, or to the currently-selected one
if none given.  


<P>

<STRONG>If a single-part entity,</STRONG>

the header and the body are both output, with the body being output
according to the encoding specified by the header.


<P>

<STRONG>If a multipart entity,</STRONG>

this is invoked recursively on all its parts, with appropriate boundaries
and a preamble generated for you.


<P>

See <CODE>print_body()</CODE> for an important note on how the body is output.


<P>

<DT><STRONG><A NAME="item_print_body_filehandle">print_body [FILEHANDLE]

</A></STRONG><DD>
<EM>Instance method, override.</EM>

Print the body of the entity to the given FILEHANDLE, or to the
currently-selected one if none given.  


<P>

<STRONG>Important note:</STRONG>
 the body is output according to the encoding specified by the header (<CODE>'binary'</CODE> if no encoding given). This means that the following code:


<P>

<PRE>
    $ent = new MIME::Entity [&quot;Subject: Greetings\n&quot;,
			     &quot;Content-transfer-encoding: base64\n&quot;,
			     &quot;\n&quot;,
			     &quot;Hi there!\n&quot;, 
			     &quot;Bye there!\n&quot;
			     ];
    $ent-&gt;print;   # uses print_body() internally
</PRE>

<P>

Prints this:


<P>

<PRE>
    Subject: Greetings
    Content-transfer-encoding: base64
</PRE>

<P>

<PRE>
    SGkgdGhlcmUhCkJ5ZSB0aGVyZSEK
</PRE>

<P>

The body is <EM>stored</EM>
 in an un-encoded form; however, the idea is that the transfer encoding is
used to determine how it should be <EM>output.</EM>

This means that the <CODE>print()</CODE> method is always guaranteed to get you a sendmail-ready stream whose body
is consistent with its head.


<P>

If you want the raw body data to be output, you can either read it from the
bodyhandle yourself, or use:


<P>

<PRE>
    $ent-&gt;bodyhandle-&gt;print;
</PRE>

<P>

which uses <CODE>read()</CODE> calls to extract the information, and thus
will work with both text and binary bodies.


<P>

<STRONG>Warning:</STRONG>
 Please supply a filehandle. This override method differs from
Mail::Internet's behavior, which outputs to the STDOUT if no filehandle is
given: this may lead to confusion.


<P>

<DT><STRONG><A NAME="item_purge">purge

</A></STRONG><DD>
<EM>Instance method.</EM>

Recursively purge all <EM>on-disk</EM>
 body parts in this message. This assumes that the <CODE>path()</CODE>
method returns something reasonable for the ``bodyhandle'' object... <A
HREF="Body.html">MIME::Body::File</A> and <A
HREF="Body.html">MIME::Body::Scalar</A> do, at least.


<P>

I wouldn't attempt to read those body files after you do this, for obvious
reasons. I probably should nuke the bodyhandle's path afterwards, but
currently I don't. Don't gamble on this for the future, though.


<P>

<EM>Thanks to Jason L. Tibbitts III for suggesting this method.</EM>





<P>

<DT><STRONG><A NAME="item_remove_sig_nlines">remove_sig [NLINES]

</A></STRONG><DD>
<EM>Instance method, override.</EM>

Attempts to remove a user's signature from the body of a message. 


<P>

It does this by looking for a line matching <CODE>/^-- $/</CODE> within the last 
<CODE>NLINES</CODE> of the message. If found then that line and all lines after it will be
removed. If <CODE>NLINES</CODE> is not given, a default value of 10 will be used. This would be of most use
in auto-reply scripts.


<P>

For MIME messages, this method is reasonably cautious: it will only attempt
to un-sign a message with a content-type of <CODE>text/*</CODE>.


<P>

If you send this message to a multipart entity, it will relay it to the
first part (the others usually being the ``attachments'').


<P>

<STRONG>Warning:</STRONG>
 currently slurps the whole message-part into core as an array of lines, so
you probably don't want to use this on extremely long messages.


<P>

Returns truth on success, false on error.


<P>

<DT><STRONG><A NAME="item_sign_paramhash">sign PARAMHASH

</A></STRONG><DD>
<EM>Instance method, override.</EM>

Append a signature to the message. The params are:


<P>

<DL>
<DT><STRONG><A NAME="item_attach">Attach

</A></STRONG><DD>
Instead of appending the text, try to add it to the message as an
attachment. The disposition will be <CODE>inline</CODE>, and the description will indicate that it is a signature. Attaching is <EM>only</EM>
 done if the message type is multipart; otherwise, we try to append the
signature to the text itself.
<EM>MIME-specific; new in this subclass.</EM>





<P>

<DT><STRONG><A NAME="item_file">File

</A></STRONG><DD>
Use the contents of this file as the signature. Fatal error if it can't be
read.
<EM>As per superclass method.</EM>





<P>

<DT><STRONG><A NAME="item_force">Force

</A></STRONG><DD>
Sign it even if the content-type isn't <CODE>text/*</CODE>. Useful for non-standard types like <CODE>x-foobar</CODE>, but be careful!
<EM>MIME-specific; new in this subclass.</EM>





<P>

<DT><STRONG><A NAME="item_remove">Remove

</A></STRONG><DD>
Normally, we attempt to strip out any existing signature. If true, this
gives us the NLINES parameter of the remove_sig call. If zero but defined,
tells us <EM>not</EM>
 to remove any existing signature. If undefined, removal is done with the
default of 10 lines.
<EM>New in this subclass.</EM>





<P>

<DT><STRONG><A NAME="item_signature">Signature

</A></STRONG><DD>
Use this text as the signature. You can supply it as either a scalar, or as
a ref to an array of newline-terminated scalars.
<EM>As per superclass method.</EM>





<P>

</DL>
For MIME messages, this method is reasonably cautious: it will only attempt
to sign a message with a content-type of <CODE>text/*</CODE>, unless
<A HREF="#item_force">Force</A> is specified.


<P>

If you send this message to a multipart entity, it will relay it to the
first part (the others usually being the ``attachments'').


<P>

<STRONG>Warning:</STRONG>
 currently slurps the whole message-part into core as an array of lines, so
you probably don't want to use this on extremely long messages.


<P>

Returns true on success, false otherwise.


<P>

<DT><STRONG><A NAME="item_sync_headers_options">sync_headers OPTIONS

</A></STRONG><DD>
This method does a variety of activities which ensure that the MIME headers
of an entity ``tree'' are in-synch with the body parts they describe. It
can be as expensive an operation as printing if it involves pre-encoding
the body parts; however, the aim is to produce fairly clean MIME.  <STRONG>You will usually only need to invoke this if processing and re-sending MIME
from an outside source.</STRONG>





<P>

The OPTIONS is a hash, which describes what is to be done.


<P>

<DL>
<DT><STRONG><A NAME="item_length">Length

</A></STRONG><DD>
One of the ``official unofficial'' MIME fields is ``Content-Length''.
Normally, one doesn't care a whit about this field; however, if you are
preparing output destined for HTTP, you may. The value of this option
dictates what will be done:


<P>

<STRONG>COMPUTE</STRONG>
 means to set a <CODE>Content-Length</CODE> field for every non-multipart part in the entity, and to blank that field
out for every multipart part in the entity. 


<P>

<STRONG>ERASE</STRONG>
 means that <CODE>Content-Length</CODE> fields will all be blanked out. This is fast, painless, and safe.


<P>

<STRONG>Any false value</STRONG>
 (the default) means to take no action.


<P>

<DT><STRONG><A NAME="item_nonstandard">Nonstandard

</A></STRONG><DD>
Any header field beginning with ``Content-'' is, according to the RFC, a
MIME field. However, some are non-standard, and may cause problems with
certain MIME readers which interpret them in different ways.


<P>

<STRONG>ERASE</STRONG>
 means that all such fields will be blanked out. This is done <EM>before</EM>
 the <STRONG>Length</STRONG>
 option (q.v.) is examined and acted upon.


<P>

<STRONG>Any false value</STRONG>
 (the default) means to take no action.


<P>

</DL>
Returns a true value if everything went okay, a false value otherwise.


<P>

<DT><STRONG><A NAME="item_tidy_body">tidy_body

</A></STRONG><DD>
<EM>Instance method, override.</EM>

Currently unimplemented for MIME messages. Does nothing, returns false.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="notes">NOTES</A></H2>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="under_the_hood">Under the hood</A></H3>
A <STRONG><A HREF="Entity.html">MIME::Entity</A></STRONG>
 is composed of the following elements:


<P>

<UL>
<LI><STRONG></STRONG>
A <EM>head</EM>
, which is a reference to a <A HREF="Head.html">MIME::Head</A> object
containing the header information.


<P>

<LI><STRONG></STRONG>
A <EM>bodyhandle</EM>
, which is a reference a <A HREF="Body.html">MIME::Body</A> object
containing the decoded body data. (In pre-2.0 releases, this was accessed
via <EM>body</EM>
, which was a path to a file containing the decoded body. Integration with
Mail::Internet has forced this to change.)


<P>

<LI><STRONG></STRONG>
A list of zero or more <EM>parts</EM>
, each of which is a <A HREF="Entity.html">MIME::Entity</A> object. The
number of parts will only be nonzero if the content-type is some subtype of <CODE>"multipart"</CODE>.


<P>

Note that, in 2.0+, a multipart entity does <EM>not</EM>
 have a body. Of course, any/all of its component parts can have bodies.


<P>

</UL>
<P>
<HR ALIGN=LEFT WIDTH=75%>
<H3><A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="*" BORDER=0></A> <A NAME="design_issues">Design issues</A></H3>
<DL>
<DT><STRONG><A NAME="item_some_things_just_cant_be_ignored">Some things just can't be ignored

</A></STRONG><DD>
In multipart messages, the <EM>``preamble''</EM>
 is the portion that precedes the first encapsulation boundary, and the <EM>``epilogue''</EM>
 is the portion that follows the last encapsulation boundary.


<P>

According to RFC-1521:


<P>

<PRE>
    There appears to be room for additional information prior to the
    first encapsulation boundary and following the final boundary.  These
    areas should generally be left blank, and implementations must ignore
    anything that appears before the first boundary or after the last one.
</PRE>

<P>

<PRE>
    NOTE: These &quot;preamble&quot; and &quot;epilogue&quot; areas are generally not used
    because of the lack of proper typing of these parts and the lack
    of clear semantics for handling these areas at gateways,
    particularly X.400 gateways.  However, rather than leaving the
    preamble area blank, many MIME implementations have found this to
    be a convenient place to insert an explanatory note for recipients
    who read the message with pre-MIME software, since such notes will
    be ignored by MIME-compliant software.
</PRE>

<P>

In the world of standards-and-practices, that's the standard. Now for the
practice: 


<P>

<EM>Some ``MIME'' mailers may incorrectly put a ``part'' in the preamble</EM>
. Since we have to parse over the stuff <EM>anyway</EM>
, in the future I
<EM>may</EM>
 allow the parser option of creating special <A
HREF="Entity.html">MIME::Entity</A> objects for the preamble and epilogue,
with bogus <A HREF="Head.html">MIME::Head</A> objects.


<P>

For now, though, we're MIME-compliant, so I probably won't change how we
work.


<P>

</DL>
<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="author">AUTHOR</A></H2>
Copyright (c) 1996 by Eryq / <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A>


<P>

All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


<P>

<P>
<HR ALIGN=LEFT WIDTH=100%>
<H2><A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="*" BORDER=0></A> <A NAME="version">VERSION</A></H2>
$Revision: 3.202 $ $Date: 1997/01/19 07:10:41 $


<P>

</BODY>
</HTML>
